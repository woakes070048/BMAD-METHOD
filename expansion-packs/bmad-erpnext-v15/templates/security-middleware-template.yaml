name: "security-middleware-template"
title: "Security Middleware and CSRF Protection Template"
description: "Complete security templates for production ERPNext apps"
version: "2.0.0"

parameters:
  app_name:
    type: "string"
    required: true
    description: "Name of the ERPNext app (snake_case)"
  site_name:
    type: "string"
    required: true
    description: "Site name for security configuration"

templates:
  csrf_handler: |
    // utils/csrf.js
    /**
     * CSRF Token Management Utility
     * Handles CSRF token acquisition, validation, and refresh
     */
    
    class CSRFTokenManager {
      constructor() {
        this.token = null
        this.tokenExpiry = null
        this.refreshPromise = null
      }
    
      /**
       * Get current CSRF token
       * Automatically refreshes if expired
       */
      async getToken() {
        if (!this.token || this.isTokenExpired()) {
          await this.refreshToken()
        }
        return this.token
      }
    
      /**
       * Initialize token from DOM or fetch from server
       */
      async initializeToken() {
        // Try to get token from meta tag first (SSR)
        const metaToken = document.querySelector('meta[name="csrf-token"]')?.content
        if (metaToken) {
          this.setToken(metaToken)
          return metaToken
        }
    
        // Try to get from window object
        if (window.csrf_token) {
          this.setToken(window.csrf_token)
          return window.csrf_token
        }
    
        // Fetch from server
        return await this.fetchTokenFromServer()
      }
    
      /**
       * Set token with expiry
       */
      setToken(token, expiryMinutes = 60) {
        this.token = token
        this.tokenExpiry = new Date(Date.now() + expiryMinutes * 60 * 1000)
        
        // Update DOM elements
        this.updateDOMToken(token)
      }
    
      /**
       * Check if current token is expired
       */
      isTokenExpired() {
        if (!this.tokenExpiry) return true
        return new Date() >= this.tokenExpiry
      }
    
      /**
       * Refresh token from server
       */
      async refreshToken() {
        // Prevent multiple simultaneous refresh requests
        if (this.refreshPromise) {
          return await this.refreshPromise
        }
    
        this.refreshPromise = this.fetchTokenFromServer()
        
        try {
          const token = await this.refreshPromise
          return token
        } finally {
          this.refreshPromise = null
        }
      }
    
      /**
       * Fetch fresh token from server
       */
      async fetchTokenFromServer() {
        try {
          const response = await fetch('/api/method/frappe.sessions.get_csrf_token', {
            method: 'POST',
            credentials: 'include',
            headers: {
              'Content-Type': 'application/json',
            },
          })
    
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
          }
    
          const data = await response.json()
          
          if (data.message && data.message.csrf_token) {
            this.setToken(data.message.csrf_token)
            return data.message.csrf_token
          }
          
          throw new Error('No CSRF token in response')
        } catch (error) {
          console.error('Failed to fetch CSRF token:', error)
          throw error
        }
      }
    
      /**
       * Update DOM with new token
       */
      updateDOMToken(token) {
        // Update meta tag
        let metaTag = document.querySelector('meta[name="csrf-token"]')
        if (!metaTag) {
          metaTag = document.createElement('meta')
          metaTag.name = 'csrf-token'
          document.head.appendChild(metaTag)
        }
        metaTag.content = token
    
        // Update window object
        window.csrf_token = token
    
        // Update any hidden form inputs
        const hiddenInputs = document.querySelectorAll('input[name="csrf_token"]')
        hiddenInputs.forEach(input => {
          input.value = token
        })
      }
    
      /**
       * Clear stored token
       */
      clearToken() {
        this.token = null
        this.tokenExpiry = null
        this.updateDOMToken('')
      }
    
      /**
       * Validate token format
       */
      isValidTokenFormat(token) {
        // Frappe CSRF tokens are typically base64 encoded
        if (!token || typeof token !== 'string') return false
        
        // Basic length and character validation
        return token.length >= 20 && /^[A-Za-z0-9+/=]+$/.test(token)
      }
    }
    
    // Global instance
    export const csrfManager = new CSRFTokenManager()
    
    // Initialize on import
    csrfManager.initializeToken().catch(console.error)
    
    export default csrfManager

  api_interceptor: |
    // utils/apiInterceptor.js
    /**
     * API Request Interceptor with Security Features
     * Handles CSRF tokens, rate limiting, and error handling
     */
    
    import { csrfManager } from './csrf.js'
    
    class APIInterceptor {
      constructor() {
        this.requestQueue = new Map()
        this.rateLimiters = new Map()
        this.retryQueue = new Map()
      }
    
      /**
       * Enhanced fetch with security features
       */
      async securedFetch(url, options = {}) {
        // Prepare request
        const request = await this.prepareSecureRequest(url, options)
        
        // Check rate limiting
        if (this.isRateLimited(url)) {
          throw new Error('Rate limit exceeded. Please try again later.')
        }
        
        // Execute request with retry logic
        return await this.executeWithRetry(request)
      }
    
      /**
       * Prepare request with security headers and CSRF token
       */
      async prepareSecureRequest(url, options) {
        const secureOptions = { ...options }
        
        // Initialize headers
        secureOptions.headers = {
          'Content-Type': 'application/json',
          ...secureOptions.headers,
        }
    
        // Add CSRF token for non-GET requests
        if (options.method && options.method.toUpperCase() !== 'GET') {
          try {
            const csrfToken = await csrfManager.getToken()
            secureOptions.headers['X-Frappe-CSRF-Token'] = csrfToken
          } catch (error) {
            console.error('Failed to get CSRF token:', error)
            throw new Error('Security token unavailable. Please refresh the page.')
          }
        }
    
        // Add request ID for tracking
        const requestId = this.generateRequestId()
        secureOptions.headers['X-Request-ID'] = requestId
    
        // Ensure credentials are included
        secureOptions.credentials = secureOptions.credentials || 'include'
    
        // Add security headers
        secureOptions.headers['X-Requested-With'] = 'XMLHttpRequest'
        secureOptions.headers['Cache-Control'] = 'no-cache'
    
        return {
          url,
          options: secureOptions,
          requestId,
          timestamp: Date.now(),
        }
      }
    
      /**
       * Execute request with automatic retry for certain errors
       */
      async executeWithRetry(request, maxRetries = 3) {
        let lastError
        
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
          try {
            // Add attempt header
            request.options.headers['X-Retry-Attempt'] = attempt.toString()
            
            // Execute request
            const response = await fetch(request.url, request.options)
            
            // Handle CSRF token refresh
            if (response.status === 403 && attempt < maxRetries) {
              const errorText = await response.text()
              if (errorText.includes('csrf') || errorText.includes('CSRF')) {
                console.log('CSRF token expired, refreshing...')
                await csrfManager.refreshToken()
                
                // Update request with new token
                const newToken = await csrfManager.getToken()
                request.options.headers['X-Frappe-CSRF-Token'] = newToken
                
                continue // Retry with new token
              }
            }
            
            // Handle rate limiting
            if (response.status === 429) {
              const retryAfter = response.headers.get('Retry-After')
              const delay = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, attempt) * 1000
              
              if (attempt < maxRetries) {
                console.log(`Rate limited, retrying after ${delay}ms`)
                await this.delay(delay)
                continue
              }
            }
            
            // Handle other server errors
            if (response.status >= 500 && attempt < maxRetries) {
              const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000
              console.log(`Server error ${response.status}, retrying after ${delay}ms`)
              await this.delay(delay)
              continue
            }
            
            // Log successful request
            this.logRequest(request, response, attempt)
            
            return response
            
          } catch (error) {
            lastError = error
            
            // Network errors - retry with exponential backoff
            if (attempt < maxRetries && this.isRetryableError(error)) {
              const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000
              console.log(`Network error, retrying after ${delay}ms:`, error.message)
              await this.delay(delay)
              continue
            }
            
            break
          }
        }
        
        // All retries failed
        console.error('Request failed after all retries:', lastError)
        throw lastError
      }
    
      /**
       * Check if error is retryable
       */
      isRetryableError(error) {
        const retryableErrors = [
          'Failed to fetch',
          'NetworkError',
          'net::ERR_NETWORK_CHANGED',
          'net::ERR_INTERNET_DISCONNECTED',
          'net::ERR_CONNECTION_RESET',
        ]
        
        return retryableErrors.some(msg => 
          error.message.includes(msg) || error.name.includes(msg)
        )
      }
    
      /**
       * Simple rate limiting check
       */
      isRateLimited(url) {
        const endpoint = this.getEndpointKey(url)
        const limiter = this.rateLimiters.get(endpoint)
        
        if (!limiter) {
          this.rateLimiters.set(endpoint, {
            requests: 1,
            windowStart: Date.now(),
            limit: 100, // requests per minute
            window: 60000, // 1 minute
          })
          return false
        }
        
        const now = Date.now()
        
        // Reset window if expired
        if (now - limiter.windowStart > limiter.window) {
          limiter.requests = 1
          limiter.windowStart = now
          return false
        }
        
        // Check limit
        if (limiter.requests >= limiter.limit) {
          return true
        }
        
        limiter.requests++
        return false
      }
    
      /**
       * Get endpoint key for rate limiting
       */
      getEndpointKey(url) {
        try {
          const urlObj = new URL(url, window.location.origin)
          return urlObj.pathname
        } catch {
          return url
        }
      }
    
      /**
       * Generate unique request ID
       */
      generateRequestId() {
        return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      }
    
      /**
       * Delay utility
       */
      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms))
      }
    
      /**
       * Log request for monitoring
       */
      logRequest(request, response, attempts) {
        if (process.env.NODE_ENV === 'development') {
          console.log(`API Request: ${request.options.method || 'GET'} ${request.url}`, {
            status: response.status,
            attempts: attempts + 1,
            duration: Date.now() - request.timestamp,
            requestId: request.requestId,
          })
        }
      }
    }
    
    // Global instance
    export const apiInterceptor = new APIInterceptor()
    
    // Enhanced fetch function
    export const securedFetch = (url, options) => 
      apiInterceptor.securedFetch(url, options)
    
    export default apiInterceptor

  frappe_ui_security: |
    // utils/frappeUISecurity.js
    /**
     * Enhanced frappe-ui configuration with security features
     */
    
    import { setConfig, frappeRequest } from 'frappe-ui'
    import { csrfManager } from './csrf.js'
    import { apiInterceptor } from './apiInterceptor.js'
    
    /**
     * Configure frappe-ui with enhanced security
     */
    export function configureSecuredFrappeUI() {
      // Custom request function with security
      const securedFrappeRequest = async (url, options = {}) => {
        // Prepare secure request
        const secureOptions = { ...options }
        
        // Add CSRF token for non-GET requests
        if (options.method && options.method.toUpperCase() !== 'GET') {
          const csrfToken = await csrfManager.getToken()
          secureOptions.headers = {
            ...secureOptions.headers,
            'X-Frappe-CSRF-Token': csrfToken,
          }
        }
        
        // Use secured fetch
        return apiInterceptor.securedFetch(url, secureOptions)
      }
    
      // Configure frappe-ui
      setConfig('resourceFetcher', securedFrappeRequest)
      
      // Configure base request settings
      frappeRequest.configure({
        baseURL: '',
        timeout: 30000, // 30 second timeout
        headers: {
          'X-Requested-With': 'XMLHttpRequest',
          'Cache-Control': 'no-cache',
        },
        credentials: 'include',
      })
    }
    
    /**
     * Create secured resource with automatic error handling
     */
    export function createSecuredResource(config) {
      const enhancedConfig = {
        ...config,
        onError: (error) => {
          // Handle security errors
          if (error.response?.status === 403) {
            handleSecurityError('Access denied', error)
          } else if (error.response?.status === 401) {
            handleSecurityError('Authentication required', error)
          } else if (error.response?.status === 429) {
            handleSecurityError('Rate limit exceeded', error)
          }
          
          // Call original error handler
          if (config.onError) {
            config.onError(error)
          }
        },
        
        // Add retry logic for network errors
        retries: config.retries || 3,
        retryDelay: config.retryDelay || 1000,
      }
      
      return createResource(enhancedConfig)
    }
    
    /**
     * Handle security-related errors
     */
    function handleSecurityError(message, error) {
      console.error('Security Error:', message, error)
      
      // Show user-friendly error message
      if (window.showToast) {
        window.showToast({
          type: 'error',
          title: 'Security Error',
          message: message,
          duration: 5000,
        })
      }
      
      // Redirect to login if unauthorized
      if (error.response?.status === 401) {
        window.location.href = '/login'
      }
    }

  input_sanitization: |
    // utils/inputSanitization.js
    /**
     * Input sanitization and validation utilities
     */
    
    import DOMPurify from 'dompurify'
    
    /**
     * Sanitize HTML content
     */
    export function sanitizeHTML(dirty, options = {}) {
      const defaultOptions = {
        ALLOWED_TAGS: [
          'b', 'i', 'em', 'strong', 'u', 'p', 'br', 'span', 'div',
          'ul', 'ol', 'li', 'a', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'
        ],
        ALLOWED_ATTR: ['href', 'title', 'class', 'id'],
        ALLOW_DATA_ATTR: false,
        FORBID_TAGS: ['script', 'object', 'embed', 'link', 'style'],
        FORBID_ATTR: ['onerror', 'onload', 'onclick', 'onmouseover'],
      }
      
      const config = { ...defaultOptions, ...options }
      
      return DOMPurify.sanitize(dirty, config)
    }
    
    /**
     * Sanitize user input for API calls
     */
    export function sanitizeInput(input) {
      if (typeof input !== 'string') return input
      
      // Remove control characters
      let sanitized = input.replace(/[\x00-\x1F\x7F]/g, '')
      
      // Trim whitespace
      sanitized = sanitized.trim()
      
      // Limit length to prevent DoS
      if (sanitized.length > 10000) {
        sanitized = sanitized.substring(0, 10000)
      }
      
      return sanitized
    }
    
    /**
     * Validate email format
     */
    export function validateEmail(email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      return emailRegex.test(email) && email.length <= 320 // RFC 5321 limit
    }
    
    /**
     * Validate URL format
     */
    export function validateURL(url) {
      try {
        const urlObj = new URL(url)
        // Only allow http and https protocols
        return ['http:', 'https:'].includes(urlObj.protocol)
      } catch {
        return false
      }
    }
    
    /**
     * Sanitize object for API submission
     */
    export function sanitizeObject(obj) {
      if (obj === null || obj === undefined) return obj
      
      if (Array.isArray(obj)) {
        return obj.map(sanitizeObject)
      }
      
      if (typeof obj === 'object') {
        const sanitized = {}
        for (const [key, value] of Object.entries(obj)) {
          // Sanitize key
          const cleanKey = sanitizeInput(key)
          if (cleanKey && cleanKey.length > 0) {
            sanitized[cleanKey] = sanitizeObject(value)
          }
        }
        return sanitized
      }
      
      if (typeof obj === 'string') {
        return sanitizeInput(obj)
      }
      
      return obj
    }
    
    /**
     * Validate file upload
     */
    export function validateFileUpload(file, options = {}) {
      const {
        maxSize = 10 * 1024 * 1024, // 10MB default
        allowedTypes = ['image/*', 'application/pdf', 'text/*'],
        allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.txt', '.csv'],
      } = options
      
      const errors = []
      
      // Check file size
      if (file.size > maxSize) {
        errors.push(`File size exceeds ${Math.round(maxSize / 1024 / 1024)}MB limit`)
      }
      
      // Check file type
      const isTypeAllowed = allowedTypes.some(type => {
        if (type.endsWith('/*')) {
          return file.type.startsWith(type.slice(0, -1))
        }
        return file.type === type
      })
      
      if (!isTypeAllowed) {
        errors.push(`File type ${file.type} is not allowed`)
      }
      
      // Check file extension
      const extension = '.' + file.name.split('.').pop().toLowerCase()
      if (!allowedExtensions.includes(extension)) {
        errors.push(`File extension ${extension} is not allowed`)
      }
      
      // Check filename for suspicious content
      const suspiciousPatterns = [
        /\.php$/i, /\.asp$/i, /\.jsp$/i, /\.exe$/i, /\.bat$/i, /\.cmd$/i,
        /\.scr$/i, /\.vbs$/i, /\.js$/i, /\.jar$/i
      ]
      
      if (suspiciousPatterns.some(pattern => pattern.test(file.name))) {
        errors.push('File type is potentially unsafe')
      }
      
      return {
        valid: errors.length === 0,
        errors,
      }
    }

  security_middleware: |
    # {{app_name}}/security_middleware.py
    """
    Security middleware for enhanced protection
    """
    
    import frappe
    from frappe import _
    import hashlib
    import time
    import json
    from typing import Dict, Any, Optional
    
    
    class SecurityMiddleware:
        """Enhanced security middleware for API endpoints"""
        
        def __init__(self):
            self.rate_limiters = {}
            self.request_signatures = set()
            self.max_request_size = 10 * 1024 * 1024  # 10MB
        
        def before_request(self):
            """Execute before each request"""
            try:
                # Rate limiting
                self.check_rate_limit()
                
                # Request size validation
                self.validate_request_size()
                
                # CSRF validation for non-GET requests
                if frappe.request.method != 'GET':
                    self.validate_csrf_token()
                
                # Content type validation
                self.validate_content_type()
                
                # Request signature validation (prevent replay attacks)
                self.validate_request_signature()
                
            except frappe.exceptions.SecurityException:
                raise
            except Exception as e:
                frappe.log_error(f"Security middleware error: {e}")
                frappe.throw(_("Security validation failed"))
        
        def check_rate_limit(self):
            """Check if request is within rate limits"""
            user = frappe.session.user
            ip_address = frappe.local.request_ip
            
            # Use combination of user and IP for rate limiting
            key = f"{user}:{ip_address}"
            current_time = time.time()
            
            if key not in self.rate_limiters:
                self.rate_limiters[key] = {
                    'requests': [],
                    'window': 60,  # 1 minute
                    'limit': 100,  # 100 requests per minute
                }
            
            limiter = self.rate_limiters[key]
            
            # Clean old requests
            limiter['requests'] = [
                req_time for req_time in limiter['requests']
                if current_time - req_time < limiter['window']
            ]
            
            # Check limit
            if len(limiter['requests']) >= limiter['limit']:
                frappe.log_error(f"Rate limit exceeded for {key}")
                frappe.throw(
                    _("Rate limit exceeded. Please try again later."),
                    frappe.TooManyRequestsError
                )
            
            # Add current request
            limiter['requests'].append(current_time)
        
        def validate_request_size(self):
            """Validate request content length"""
            content_length = frappe.request.environ.get('CONTENT_LENGTH')
            
            if content_length:
                try:
                    size = int(content_length)
                    if size > self.max_request_size:
                        frappe.throw(
                            _("Request size too large"),
                            frappe.RequestSizeTooLargeError
                        )
                except ValueError:
                    frappe.throw(_("Invalid content length"))
        
        def validate_csrf_token(self):
            """Enhanced CSRF token validation"""
            if frappe.session.user == "Guest":
                return  # Skip for guest users
            
            # Check for CSRF token in headers
            csrf_token = (
                frappe.get_request_header("X-Frappe-CSRF-Token") or
                frappe.form_dict.get("csrf_token")
            )
            
            if not csrf_token:
                frappe.log_error("Missing CSRF token", "Security")
                frappe.throw(
                    _("CSRF token is required"),
                    frappe.CSRFTokenError
                )
            
            # Validate token format and value
            if not self.is_valid_csrf_token(csrf_token):
                frappe.log_error(f"Invalid CSRF token: {csrf_token[:20]}...", "Security")
                frappe.throw(
                    _("Invalid CSRF token"),
                    frappe.CSRFTokenError
                )
        
        def validate_content_type(self):
            """Validate content type for POST requests"""
            if frappe.request.method in ['POST', 'PUT', 'PATCH']:
                content_type = frappe.get_request_header('Content-Type') or ''
                
                allowed_types = [
                    'application/json',
                    'application/x-www-form-urlencoded',
                    'multipart/form-data',
                ]
                
                if not any(allowed in content_type for allowed in allowed_types):
                    frappe.throw(_("Invalid content type"))
        
        def validate_request_signature(self):
            """Prevent replay attacks with request signatures"""
            # Skip for GET requests
            if frappe.request.method == 'GET':
                return
            
            timestamp = frappe.get_request_header('X-Timestamp')
            signature = frappe.get_request_header('X-Request-Signature')
            
            if not timestamp or not signature:
                return  # Optional feature
            
            try:
                request_time = float(timestamp)
                current_time = time.time()
                
                # Check timestamp freshness (5 minutes)
                if abs(current_time - request_time) > 300:
                    frappe.throw(_("Request timestamp too old"))
                
                # Generate expected signature
                request_data = frappe.request.get_data(as_text=True) or ''
                expected_sig = self.generate_request_signature(
                    timestamp, request_data
                )
                
                if signature != expected_sig:
                    frappe.log_error("Invalid request signature", "Security")
                    frappe.throw(_("Invalid request signature"))
                
                # Check for replay attacks
                sig_hash = hashlib.sha256(signature.encode()).hexdigest()
                if sig_hash in self.request_signatures:
                    frappe.throw(_("Duplicate request detected"))
                
                self.request_signatures.add(sig_hash)
                
                # Clean old signatures (keep last 1000)
                if len(self.request_signatures) > 1000:
                    # Convert to list, sort by time, keep recent ones
                    # This is a simplified approach
                    self.request_signatures = set(
                        list(self.request_signatures)[-500:]
                    )
                
            except ValueError:
                frappe.throw(_("Invalid timestamp format"))
        
        def is_valid_csrf_token(self, token: str) -> bool:
            """Validate CSRF token format and value"""
            # Get session token for comparison
            session_token = frappe.session.get('csrf_token')
            
            if not session_token:
                return False
            
            # Compare tokens
            return token == session_token
        
        def generate_request_signature(self, timestamp: str, data: str) -> str:
            """Generate request signature for validation"""
            # Use a secret key from site config
            secret_key = frappe.conf.get('secret_key', 'default-secret')
            
            # Create signature
            message = f"{timestamp}:{data}"
            signature = hashlib.hmac.new(
                secret_key.encode(),
                message.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return signature
    
    
    # Global middleware instance
    security_middleware = SecurityMiddleware()
    
    
    def before_request():
        """Hook function for before_request"""
        try:
            security_middleware.before_request()
        except Exception as e:
            frappe.log_error(f"Security middleware error: {e}", "Security")
            # Don't block requests on middleware errors in production
            if frappe.conf.get('developer_mode'):
                raise

  production_security_config: |
    # security_config.py
    """
    Production security configuration
    """
    
    SECURITY_HEADERS = {
        # Prevent clickjacking
        'X-Frame-Options': 'DENY',
        
        # Prevent MIME type sniffing
        'X-Content-Type-Options': 'nosniff',
        
        # Enable XSS protection
        'X-XSS-Protection': '1; mode=block',
        
        # Strict transport security (HTTPS only)
        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
        
        # Referrer policy
        'Referrer-Policy': 'strict-origin-when-cross-origin',
        
        # Content security policy
        'Content-Security-Policy': (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net; "
            "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; "
            "font-src 'self' https://fonts.gstatic.com; "
            "img-src 'self' data: https:; "
            "connect-src 'self' wss: ws:; "
            "frame-ancestors 'none';"
        ),
        
        # Feature policy
        'Permissions-Policy': (
            "geolocation=(), "
            "microphone=(), "
            "camera=(), "
            "payment=(), "
            "usb=(), "
            "magnetometer=(), "
            "gyroscope=(), "
            "speaker=()"
        ),
    }
    
    # Session configuration
    SESSION_CONFIG = {
        'cookie_secure': True,  # HTTPS only
        'cookie_httponly': True,  # No JavaScript access
        'cookie_samesite': 'Strict',  # CSRF protection
        'session_timeout': 3600,  # 1 hour
        'absolute_timeout': 28800,  # 8 hours
    }
    
    # File upload restrictions
    FILE_UPLOAD_CONFIG = {
        'max_file_size': 10 * 1024 * 1024,  # 10MB
        'allowed_extensions': [
            '.jpg', '.jpeg', '.png', '.gif', '.bmp',
            '.pdf', '.doc', '.docx', '.xls', '.xlsx',
            '.txt', '.csv', '.zip'
        ],
        'blocked_extensions': [
            '.exe', '.bat', '.cmd', '.scr', '.vbs',
            '.js', '.php', '.asp', '.jsp', '.jar'
        ],
        'scan_uploads': True,  # Enable virus scanning if available
    }
    
    # API rate limiting
    RATE_LIMIT_CONFIG = {
        'global_limit': 1000,  # requests per hour
        'per_user_limit': 100,  # requests per minute
        'burst_limit': 10,     # concurrent requests
        'whitelist_ips': [],   # IPs exempt from rate limiting
    }

instructions:
  setup:
    - "Install DOMPurify: yarn add dompurify"
    - "Add security utilities to your Vue app"
    - "Configure CSRF handling in main.js"
    - "Add security middleware to hooks.py"
    - "Configure production security headers"
  
  csrf_protection:
    - "Automatic CSRF token management and refresh"
    - "Integration with frappe-ui resource system"
    - "Fallback mechanisms for token acquisition"
    - "DOM synchronization for SSR compatibility"
  
  api_security:
    - "Request signing to prevent replay attacks"
    - "Automatic retry with exponential backoff"
    - "Rate limiting per user and endpoint"
    - "Request size validation and sanitization"
  
  production_hardening:
    - "Security headers for production deployment"
    - "Content Security Policy configuration"
    - "File upload restrictions and validation"
    - "Session security configuration"
    - "Input sanitization and validation utilities"