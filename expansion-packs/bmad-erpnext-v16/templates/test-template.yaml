name: "test-template"
title: "ERPNext Test Template"
description: "Comprehensive template for creating unit tests, integration tests, and test automation in ERPNext applications"
version: "1.0.0"

parameters:
  test_type:
    type: "string"
    required: true
    enum: ["unit", "integration", "api", "workflow", "doctype", "ui"]
    description: "Type of test to create"
  
  test_name:
    type: "string"
    required: true
    description: "Name of the test class or function"
  
  target_module:
    type: "string"
    required: true
    description: "Module or functionality being tested"
  
  test_data:
    type: "object"
    required: false
    description: "Test data configuration"
  
  fixtures:
    type: "array"
    required: false
    description: "Test fixtures required"
  
  mock_dependencies:
    type: "array"
    required: false
    description: "Dependencies to mock in tests"

templates:
  unit_test: |
    import unittest
    import frappe
    from frappe.tests.utils import FrappeTestCase
    {% if mock_dependencies %}
    from unittest.mock import Mock, patch, MagicMock
    {% endif %}
    {% if target_module %}
    from {{ target_module }} import {{ test_target }}
    {% endif %}
    
    class Test{{ test_name }}(FrappeTestCase):
        """
        Unit tests for {{ target_module }}
        
        Test Coverage:
        {% for coverage_item in test_coverage %}
        - {{ coverage_item }}
        {% endfor %}
        """
        
        @classmethod
        def setUpClass(cls):
            """Set up test class - runs once before all tests"""
            super().setUpClass()
            {% if class_setup %}
            {{ class_setup | indent(12) }}
            {% endif %}
        
        def setUp(self):
            """Set up each test - runs before each test method"""
            # Set test user
            frappe.set_user("Administrator")
            
            {% if test_fixtures %}
            # Create test fixtures
            {% for fixture in test_fixtures %}
            self.{{ fixture.name }} = self.create_{{ fixture.type }}({{ fixture.data }})
            {% endfor %}
            {% endif %}
            
            {% if additional_setup %}
            # Additional setup
            {{ additional_setup | indent(12) }}
            {% endif %}
        
        {% for test_case in test_cases %}
        def test_{{ test_case.name }}(self):
            """{{ test_case.description }}"""
            {% if test_case.setup %}
            # Test-specific setup
            {{ test_case.setup | indent(12) }}
            {% endif %}
            
            {% if test_case.mocks %}
            # Mock dependencies
            {% for mock in test_case.mocks %}
            with patch('{{ mock.target }}') as mock_{{ mock.name }}:
                mock_{{ mock.name }}.return_value = {{ mock.return_value }}
                {% endfor %}
                
                # Execute test
                {{ test_case.execution | indent(16) }}
                
                # Assertions
                {{ test_case.assertions | indent(16) }}
                
                # Verify mocks
                {% for mock in test_case.mocks %}
                mock_{{ mock.name }}.assert_called_with({{ mock.expected_args }})
                {% endfor %}
            {% else %}
            # Execute test
            {{ test_case.execution | indent(12) }}
            
            # Assertions
            {{ test_case.assertions | indent(12) }}
            {% endif %}
            
            {% if test_case.cleanup %}
            # Test-specific cleanup
            {{ test_case.cleanup | indent(12) }}
            {% endif %}
        
        {% endfor %}
        
        def tearDown(self):
            """Clean up after each test - runs after each test method"""
            {% if test_cleanup %}
            # Clean up test data
            {% for cleanup in test_cleanup %}
            {{ cleanup | indent(12) }}
            {% endfor %}
            {% endif %}
            
            # Reset user
            frappe.set_user("Administrator")
            
            # Rollback any database changes
            frappe.db.rollback()
        
        @classmethod
        def tearDownClass(cls):
            """Clean up test class - runs once after all tests"""
            {% if class_cleanup %}
            {{ class_cleanup | indent(12) }}
            {% endif %}
            super().tearDownClass()
        
        # Helper methods
        {% for helper in helper_methods %}
        def {{ helper.name }}(self{% if helper.parameters %}, {{ helper.parameters | join(', ') }}{% endif %}):
            """{{ helper.description }}"""
            {{ helper.implementation | indent(12) }}
        
        {% endfor %}

  integration_test: |
    import frappe
    from frappe.tests.utils import FrappeTestCase
    from frappe.utils import now_datetime, add_days
    import json
    
    class Test{{ test_name }}Integration(FrappeTestCase):
        """
        Integration tests for {{ target_module }}
        Tests end-to-end workflows and system integration
        """
        
        def setUp(self):
            """Set up integration test environment"""
            # Create test company
            self.company = self.create_test_company()
            
            # Create test users with different roles
            self.test_users = self.create_test_users()
            
            # Set up test data
            {% for data_setup in integration_data_setup %}
            {{ data_setup | indent(12) }}
            {% endfor %}
        
        def test_{{ workflow_name.lower().replace(' ', '_') }}_workflow(self):
            """Test complete {{ workflow_name }} workflow"""
            
            # Step 1: Create initial document
            doc = self.create_test_document()
            self.assertIsNotNone(doc)
            self.assertEqual(doc.docstatus, 0)
            
            # Step 2: Submit document
            doc.submit()
            self.assertEqual(doc.docstatus, 1)
            
            # Step 3: Test workflow transitions
            {% for workflow_step in workflow_steps %}
            # {{ workflow_step.description }}
            {{ workflow_step.test_code | indent(12) }}
            {% endfor %}
            
            # Step 4: Verify final state
            doc.reload()
            self.assertEqual(doc.workflow_state, "{{ expected_final_state }}")
        
        def test_api_integration(self):
            """Test API endpoints integration"""
            
            # Test authentication
            response = self.make_api_call("auth.login", {
                "usr": self.test_users["api_user"],
                "pwd": "test_password"
            })
            self.assertTrue(response.get("success"))
            
            # Test API endpoints
            {% for api_test in api_integration_tests %}
            # Test {{ api_test.endpoint }}
            response = self.make_authenticated_api_call("{{ api_test.endpoint }}", {{ api_test.data }})
            {{ api_test.assertions | indent(12) }}
            {% endfor %}
        
        def test_database_integration(self):
            """Test database operations and data integrity"""
            
            # Test CRUD operations
            {% for crud_test in crud_tests %}
            # Test {{ crud_test.operation }} on {{ crud_test.doctype }}
            {{ crud_test.test_code | indent(12) }}
            {% endfor %}
            
            # Test database constraints
            {% for constraint_test in constraint_tests %}
            # Test {{ constraint_test.description }}
            {{ constraint_test.test_code | indent(12) }}
            {% endfor %}
        
        def test_notification_integration(self):
            """Test email and notification integration"""
            
            # Clear email queue
            frappe.db.delete("Email Queue")
            
            # Trigger notification
            {{ notification_trigger_code | indent(12) }}
            
            # Verify email was queued
            emails = frappe.get_all("Email Queue", fields=["*"])
            self.assertTrue(len(emails) > 0)
            
            # Verify email content
            email = emails[0]
            {% for email_assertion in email_assertions %}
            {{ email_assertion | indent(12) }}
            {% endfor %}
        
        # Helper methods for integration tests
        def create_test_company(self):
            """Create test company"""
            if not frappe.db.exists("Company", "Test Company"):
                company = frappe.get_doc({
                    "doctype": "Company",
                    "company_name": "Test Company",
                    "abbr": "TC",
                    "default_currency": "USD",
                    "country": "United States"
                })
                company.insert()
                return company
            return frappe.get_doc("Company", "Test Company")
        
        def create_test_users(self):
            """Create test users with different roles"""
            users = {}
            
            {% for user_config in test_user_configs %}
            if not frappe.db.exists("User", "{{ user_config.email }}"):
                user = frappe.get_doc({
                    "doctype": "User",
                    "email": "{{ user_config.email }}",
                    "first_name": "{{ user_config.first_name }}",
                    "last_name": "{{ user_config.last_name }}",
                    "roles": [{"role": role} for role in {{ user_config.roles }}]
                })
                user.insert()
                users["{{ user_config.key }}"] = user
            else:
                users["{{ user_config.key }}"] = frappe.get_doc("User", "{{ user_config.email }}")
            {% endfor %}
            
            return users
        
        def make_api_call(self, method, data):
            """Make API call for testing"""
            return frappe.call(method, **data)
        
        def make_authenticated_api_call(self, method, data):
            """Make authenticated API call"""
            # Set test user
            frappe.set_user(self.test_users["api_user"].name)
            
            try:
                return frappe.call(method, **data)
            finally:
                frappe.set_user("Administrator")

  api_test: |
    import frappe
    from frappe.tests.utils import FrappeTestCase
    import json
    import requests
    
    class Test{{ test_name }}API(FrappeTestCase):
        """
        API endpoint tests for {{ target_module }}
        Tests REST API functionality, authentication, and error handling
        """
        
        def setUp(self):
            """Set up API test environment"""
            self.base_url = frappe.utils.get_url()
            self.api_key = self.get_or_create_api_key()
            self.api_secret = self.get_api_secret()
            
            # Create test data
            self.test_data = self.create_api_test_data()
        
        {% for endpoint_test in api_endpoint_tests %}
        def test_{{ endpoint_test.name }}_api(self):
            """Test {{ endpoint_test.description }}"""
            
            url = f"{self.base_url}/api/method/{{ endpoint_test.method }}"
            
            {% if endpoint_test.authentication_required %}
            # Test without authentication (should fail)
            response = requests.post(url, json={{ endpoint_test.test_data }})
            self.assertEqual(response.status_code, 403)
            
            # Test with authentication
            headers = {
                "Authorization": f"token {self.api_key}:{self.api_secret}"
            }
            response = requests.post(url, json={{ endpoint_test.test_data }}, headers=headers)
            {% else %}
            # Test without authentication (allowed)
            response = requests.post(url, json={{ endpoint_test.test_data }})
            {% endif %}
            
            # Verify response
            self.assertEqual(response.status_code, {{ endpoint_test.expected_status_code | default(200) }})
            
            data = response.json()
            {% for assertion in endpoint_test.response_assertions %}
            {{ assertion | indent(12) }}
            {% endfor %}
        
        {% endfor %}
        
        def test_api_error_handling(self):
            """Test API error handling"""
            
            {% for error_test in api_error_tests %}
            # Test {{ error_test.description }}
            url = f"{self.base_url}/api/method/{{ error_test.method }}"
            response = requests.post(url, json={{ error_test.invalid_data }})
            
            self.assertEqual(response.status_code, {{ error_test.expected_status }})
            data = response.json()
            self.assertFalse(data.get("success", True))
            self.assertIn("error", data)
            {% endfor %}
        
        def test_api_rate_limiting(self):
            """Test API rate limiting (if implemented)"""
            {% if rate_limit_config %}
            url = f"{self.base_url}/api/method/{{ rate_limit_config.endpoint }}"
            headers = {
                "Authorization": f"token {self.api_key}:{self.api_secret}"
            }
            
            # Make requests up to limit
            for i in range({{ rate_limit_config.limit }}):
                response = requests.post(url, json={}, headers=headers)
                self.assertEqual(response.status_code, 200)
            
            # Next request should be rate limited
            response = requests.post(url, json={}, headers=headers)
            self.assertEqual(response.status_code, 429)
            {% else %}
            self.skipTest("Rate limiting not configured")
            {% endif %}
        
        # Helper methods
        def get_or_create_api_key(self):
            """Get or create API key for testing"""
            user = frappe.get_doc("User", "Administrator")
            if not user.api_key:
                user.generate_keys()
            return user.api_key
        
        def get_api_secret(self):
            """Get API secret for testing"""
            return frappe.get_doc("User", "Administrator").get_password("api_secret")
        
        def create_api_test_data(self):
            """Create test data for API testing"""
            return {
                {% for test_data_item in api_test_data %}
                "{{ test_data_item.key }}": {{ test_data_item.value }},
                {% endfor %}
            }

  performance_test: |
    import time
    import frappe
    from frappe.tests.utils import FrappeTestCase
    from concurrent.futures import ThreadPoolExecutor
    import statistics
    
    class Test{{ test_name }}Performance(FrappeTestCase):
        """
        Performance tests for {{ target_module }}
        Tests response times, throughput, and resource usage
        """
        
        def setUp(self):
            """Set up performance test environment"""
            self.performance_data = []
            self.max_response_time = {{ max_response_time | default(2.0) }}  # seconds
            self.min_throughput = {{ min_throughput | default(10) }}  # requests per second
        
        def test_response_time(self):
            """Test API response times"""
            
            {% for performance_test in performance_tests %}
            # Test {{ performance_test.name }}
            response_times = []
            
            for i in range({{ performance_test.iterations | default(100) }}):
                start_time = time.time()
                
                # Execute operation
                {{ performance_test.operation | indent(16) }}
                
                end_time = time.time()
                response_times.append(end_time - start_time)
            
            # Analyze results
            avg_time = statistics.mean(response_times)
            max_time = max(response_times)
            percentile_95 = statistics.quantiles(response_times, n=20)[18]  # 95th percentile
            
            # Assertions
            self.assertLess(avg_time, self.max_response_time, 
                           f"Average response time {avg_time:.3f}s exceeds limit")
            self.assertLess(percentile_95, self.max_response_time * 2,
                           f"95th percentile {percentile_95:.3f}s exceeds limit")
            
            print(f"{{ performance_test.name }} - Avg: {avg_time:.3f}s, Max: {max_time:.3f}s, 95th: {percentile_95:.3f}s")
            {% endfor %}
        
        def test_concurrent_requests(self):
            """Test concurrent request handling"""
            
            def make_request():
                start_time = time.time()
                try:
                    # Make concurrent request
                    {{ concurrent_request_code | indent(20) }}
                    return time.time() - start_time, True
                except Exception as e:
                    return time.time() - start_time, False
            
            # Execute concurrent requests
            with ThreadPoolExecutor(max_workers={{ concurrent_users | default(10) }}) as executor:
                futures = [executor.submit(make_request) for _ in range({{ total_requests | default(100) }})]
                results = [future.result() for future in futures]
            
            # Analyze results
            response_times = [r[0] for r in results]
            success_rate = sum(1 for r in results if r[1]) / len(results)
            
            # Assertions
            self.assertGreaterEqual(success_rate, {{ min_success_rate | default(0.95) }},
                                  f"Success rate {success_rate:.2%} below threshold")
            
            avg_concurrent_time = statistics.mean(response_times)
            self.assertLess(avg_concurrent_time, self.max_response_time * 2,
                           f"Concurrent average time {avg_concurrent_time:.3f}s too high")
        
        def test_memory_usage(self):
            """Test memory usage during operations"""
            import psutil
            import os
            
            process = psutil.Process(os.getpid())
            initial_memory = process.memory_info().rss
            
            # Perform memory-intensive operations
            {% for memory_test in memory_tests %}
            # {{ memory_test.description }}
            {{ memory_test.operation | indent(12) }}
            
            current_memory = process.memory_info().rss
            memory_increase = current_memory - initial_memory
            
            # Check memory increase is within acceptable limits
            max_memory_increase = {{ memory_test.max_increase | default(100 * 1024 * 1024) }}  # 100MB
            self.assertLess(memory_increase, max_memory_increase,
                           f"Memory increase {memory_increase / 1024 / 1024:.1f}MB exceeds limit")
            {% endfor %}
        
        def test_database_performance(self):
            """Test database query performance"""
            
            {% for db_test in database_performance_tests %}
            # Test {{ db_test.description }}
            start_time = time.time()
            
            {{ db_test.query | indent(12) }}
            
            query_time = time.time() - start_time
            max_query_time = {{ db_test.max_time | default(1.0) }}
            
            self.assertLess(query_time, max_query_time,
                           f"Query time {query_time:.3f}s exceeds limit {max_query_time}s")
            {% endfor %}

  ui_test: |
    from frappe.tests.ui_test_base import UITestBase
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException
    
    class Test{{ test_name }}UI(UITestBase):
        """
        UI tests for {{ target_module }}
        Tests user interface functionality using Selenium
        """
        
        def setUp(self):
            """Set up UI test environment"""
            super().setUp()
            self.login_as_administrator()
        
        {% for ui_test in ui_tests %}
        def test_{{ ui_test.name }}_ui(self):
            """{{ ui_test.description }}"""
            
            # Navigate to page
            self.driver.get(f"{self.base_url}{{ ui_test.page_url }}")
            
            # Wait for page to load
            WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            
            {% for step in ui_test.steps %}
            # {{ step.description }}
            {% if step.type == 'click' %}
            element = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.{{ step.locator_type }}, "{{ step.locator }}"))
            )
            element.click()
            {% elif step.type == 'type' %}
            element = self.driver.find_element(By.{{ step.locator_type }}, "{{ step.locator }}")
            element.clear()
            element.send_keys("{{ step.text }}")
            {% elif step.type == 'select' %}
            from selenium.webdriver.support.ui import Select
            select_element = Select(self.driver.find_element(By.{{ step.locator_type }}, "{{ step.locator }}"))
            select_element.select_by_visible_text("{{ step.option }}")
            {% elif step.type == 'wait_for' %}
            WebDriverWait(self.driver, {{ step.timeout | default(10) }}).until(
                EC.{{ step.condition }}((By.{{ step.locator_type }}, "{{ step.locator }}"))
            )
            {% elif step.type == 'assert' %}
            {% if step.assertion_type == 'text' %}
            element = self.driver.find_element(By.{{ step.locator_type }}, "{{ step.locator }}")
            self.assertEqual(element.text, "{{ step.expected_text }}")
            {% elif step.assertion_type == 'visible' %}
            element = self.driver.find_element(By.{{ step.locator_type }}, "{{ step.locator }}")
            self.assertTrue(element.is_displayed())
            {% endif %}
            {% endif %}
            {% endfor %}
        
        {% endfor %}
        
        def test_responsive_design(self):
            """Test responsive design on different screen sizes"""
            
            screen_sizes = [
                (1920, 1080),  # Desktop
                (768, 1024),   # Tablet
                (375, 667)     # Mobile
            ]
            
            for width, height in screen_sizes:
                self.driver.set_window_size(width, height)
                
                # Test critical UI elements at this screen size
                {% for responsive_test in responsive_tests %}
                # {{ responsive_test.description }}
                {{ responsive_test.test_code | indent(16) }}
                {% endfor %}

  test_runner_config: |
    # Test Runner Configuration
    # Add to frappe_tests.py or test configuration
    
    import unittest
    from frappe.tests.test_runner import TestRunner
    
    class {{ test_name }}TestSuite:
        """Custom test suite for {{ target_module }}"""
        
        def __init__(self):
            self.test_loader = unittest.TestLoader()
            self.test_suite = unittest.TestSuite()
        
        def add_tests(self):
            """Add all tests to the suite"""
            
            # Unit tests
            {% for unit_test in unit_test_classes %}
            self.test_suite.addTest(self.test_loader.loadTestsFromName('{{ unit_test }}'))
            {% endfor %}
            
            # Integration tests
            {% for integration_test in integration_test_classes %}
            self.test_suite.addTest(self.test_loader.loadTestsFromName('{{ integration_test }}'))
            {% endfor %}
            
            # API tests
            {% for api_test in api_test_classes %}
            self.test_suite.addTest(self.test_loader.loadTestsFromName('{{ api_test }}'))
            {% endfor %}
        
        def run_tests(self):
            """Run all tests in the suite"""
            self.add_tests()
            
            runner = unittest.TextTestRunner(verbosity=2)
            result = runner.run(self.test_suite)
            
            return result.wasSuccessful()

examples:
  doctype_test_example:
    test_type: "unit"
    test_name: "CustomerTest"
    target_module: "myapp.customers"
    test_cases:
      - name: "customer_creation"
        description: "Test customer creation with valid data"
        execution: |
          customer_data = {
              "customer_name": "Test Customer",
              "email_id": "test@example.com"
          }
          customer = frappe.get_doc({
              "doctype": "Customer",
              **customer_data
          })
          customer.insert()
        assertions: |
          self.assertEqual(customer.customer_name, "Test Customer")
          self.assertEqual(customer.email_id, "test@example.com")
          self.assertIsNotNone(customer.name)

  api_test_example:
    test_type: "api"
    test_name: "CustomerAPI"
    target_module: "myapp.api.customer"
    api_endpoint_tests:
      - name: "create_customer"
        method: "myapp.api.create_customer"
        description: "Create customer via API"
        test_data: |
          {
              "customer_name": "API Test Customer",
              "email_id": "apitest@example.com"
          }
        response_assertions:
          - "self.assertTrue(data.get('success'))"
          - "self.assertIn('customer_id', data.get('data', {}))"

best_practices:
  test_organization:
    - "Group related tests in test classes"
    - "Use descriptive test method names"
    - "Keep tests independent and isolated"
    - "Use setUp and tearDown appropriately"
    - "Create reusable test fixtures"
  
  test_data_management:
    - "Use factories or fixtures for test data"
    - "Clean up test data after tests"
    - "Use realistic but safe test data"
    - "Avoid dependencies on production data"
  
  assertion_strategies:
    - "Use specific assertions (assertEqual vs assertTrue)"
    - "Test both positive and negative cases"
    - "Verify error messages and exceptions"
    - "Test boundary conditions"
  
  performance_testing:
    - "Set realistic performance benchmarks"
    - "Test with production-like data volumes"
    - "Monitor resource usage during tests"
    - "Test concurrent access scenarios"

test_utilities:
  common_assertions: |
    # Common test assertions for ERPNext
    
    def assert_doc_exists(self, doctype, name):
        """Assert that a document exists"""
        self.assertTrue(frappe.db.exists(doctype, name))
    
    def assert_doc_field_equals(self, doctype, name, field, value):
        """Assert that a document field has specific value"""
        actual_value = frappe.db.get_value(doctype, name, field)
        self.assertEqual(actual_value, value)
    
    def assert_permission_denied(self, func, *args, **kwargs):
        """Assert that a function raises PermissionError"""
        with self.assertRaises(frappe.PermissionError):
            func(*args, **kwargs)
    
    def assert_validation_error(self, func, *args, **kwargs):
        """Assert that a function raises ValidationError"""
        with self.assertRaises(frappe.ValidationError):
            func(*args, **kwargs)

test_commands:
  run_specific_test: "bench --site site_name run-tests --module tests.test_module"
  run_all_tests: "bench --site site_name run-tests --app app_name"
  run_with_coverage: "bench --site site_name run-tests --coverage"
  run_performance_tests: "bench --site site_name run-tests --module tests.performance"