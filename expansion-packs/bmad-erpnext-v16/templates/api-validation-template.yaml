---
template_name: "API Validation Template"
template_type: "api_security_validation"
version: "1.0.0"
description: "Template for implementing comprehensive API validation and security measures"

# API validation framework
api_validation:
  authentication_validation:
    token_validation:
      type: "bearer_token"
      header: "Authorization"
      pattern: "^Bearer [A-Za-z0-9+/=]+$"
      validation_function: "validate_bearer_token"
      error_message: "Invalid or missing bearer token"
      
    api_key_validation:
      type: "api_key"
      header: "X-API-Key"
      pattern: "^[A-Za-z0-9]{32}$"
      validation_function: "validate_api_key"
      error_message: "Invalid API key format"
      
    jwt_validation:
      type: "jwt"
      header: "Authorization"
      pattern: "^Bearer [A-Za-z0-9\\-_.]+$"
      validation_function: "validate_jwt_token"
      error_message: "Invalid JWT token"
      algorithm: "HS256"
      expiry_check: true

  input_validation:
    data_type_validation:
      string_validation:
        max_length: 255
        min_length: 1
        allowed_chars: "alphanumeric_space_punctuation"
        sanitization: "html_escape"
        
      integer_validation:
        min_value: -2147483648
        max_value: 2147483647
        type_check: true
        
      float_validation:
        precision: 2
        min_value: -999999999.99
        max_value: 999999999.99
        
      boolean_validation:
        accepted_values: [true, false, "true", "false", 1, 0, "1", "0"]
        
      email_validation:
        regex: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
        max_length: 255
        
      date_validation:
        format: "YYYY-MM-DD"
        min_date: "1900-01-01"
        max_date: "2100-12-31"
        
      datetime_validation:
        format: "YYYY-MM-DD HH:mm:ss"
        timezone_aware: true

    business_logic_validation:
      doctype_exists:
        validation_function: "validate_doctype_exists"
        error_message: "Invalid DocType specified"
        
      document_exists:
        validation_function: "validate_document_exists"
        error_message: "Document does not exist"
        
      permission_check:
        validation_function: "validate_user_permission"
        error_message: "Insufficient permissions"
        
      field_permissions:
        validation_function: "validate_field_permissions"
        error_message: "No permission to access this field"
        
      status_validation:
        allowed_statuses: ["Draft", "Submitted", "Cancelled"]
        validation_function: "validate_document_status"

  request_validation:
    http_method_validation:
      allowed_methods: ["GET", "POST", "PUT", "PATCH", "DELETE"]
      validation_function: "validate_http_method"
      
    content_type_validation:
      allowed_types:
        - "application/json"
        - "application/x-www-form-urlencoded"
        - "multipart/form-data"
      validation_function: "validate_content_type"
      
    request_size_validation:
      max_size_mb: 10
      validation_function: "validate_request_size"
      error_message: "Request size exceeds maximum limit"
      
    rate_limiting:
      requests_per_minute: 60
      burst_limit: 10
      validation_function: "validate_rate_limit"
      error_message: "Rate limit exceeded"

# Validation implementation patterns
validation_patterns:
  input_sanitization:
    html_sanitization: |
      import html
      import re
      
      def sanitize_html_input(value):
          \"\"\"Sanitize HTML input to prevent XSS\"\"\"
          if not isinstance(value, str):
              return value
          
          # Remove script tags
          value = re.sub(r'<script[^>]*>.*?</script>', '', value, flags=re.IGNORECASE | re.DOTALL)
          
          # Escape HTML entities
          value = html.escape(value)
          
          return value

    sql_injection_prevention: |
      def sanitize_sql_input(value):
          \"\"\"Prevent SQL injection in parameters\"\"\"
          if not isinstance(value, str):
              return value
          
          # Remove dangerous SQL keywords
          dangerous_patterns = [
              r'\\b(DROP|DELETE|UPDATE|INSERT|ALTER|CREATE|EXEC|UNION|SELECT)\\b',
              r'[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]',  # Control characters
              r'[\\'\\\"\\\\]'  # Quote characters
          ]
          
          for pattern in dangerous_patterns:
              if re.search(pattern, value, re.IGNORECASE):
                  raise frappe.ValidationError("Invalid input detected")
          
          return value

  authentication_validation: |
    import jwt
    import frappe
    from functools import wraps
    
    def validate_api_access(auth_methods=['token']):
        \"\"\"Decorator for API authentication validation\"\"\"
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                # Validate authentication
                if not validate_request_authentication(auth_methods):
                    frappe.throw("Authentication required", frappe.AuthenticationError)
                
                # Validate permissions
                if not validate_request_permissions():
                    frappe.throw("Insufficient permissions", frappe.PermissionError)
                
                return func(*args, **kwargs)
            return wrapper
        return decorator
    
    def validate_request_authentication(auth_methods):
        \"\"\"Validate request authentication\"\"\"
        for method in auth_methods:
            if method == 'token' and validate_token_auth():
                return True
            elif method == 'jwt' and validate_jwt_auth():
                return True
            elif method == 'session' and validate_session_auth():
                return True
        
        return False

  input_validation_decorator: |
    def validate_api_input(validation_schema):
        \"\"\"Decorator for API input validation\"\"\"
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                # Get request data
                data = frappe.local.form_dict
                
                # Validate against schema
                validation_errors = validate_data_against_schema(data, validation_schema)
                
                if validation_errors:
                    frappe.throw({
                        "message": "Input validation failed",
                        "errors": validation_errors
                    }, frappe.ValidationError)
                
                return func(*args, **kwargs)
            return wrapper
        return decorator

# Validation schemas
validation_schemas:
  create_document_schema:
    required_fields:
      - "doctype"
      - "data"
    field_validations:
      doctype:
        type: "string"
        max_length: 100
        validation: "doctype_exists"
      data:
        type: "object"
        validation: "document_data_validation"

  update_document_schema:
    required_fields:
      - "doctype"
      - "name"
      - "data"
    field_validations:
      doctype:
        type: "string"
        validation: "doctype_exists"
      name:
        type: "string"
        validation: "document_exists"
      data:
        type: "object"
        validation: "update_data_validation"

  delete_document_schema:
    required_fields:
      - "doctype"
      - "name"
    field_validations:
      doctype:
        type: "string"
        validation: "doctype_exists"
      name:
        type: "string"
        validation: "document_exists"

  search_schema:
    required_fields:
      - "doctype"
    optional_fields:
      - "filters"
      - "fields"
      - "limit"
      - "offset"
    field_validations:
      doctype:
        type: "string"
        validation: "doctype_exists"
      filters:
        type: "object"
        validation: "search_filters_validation"
      limit:
        type: "integer"
        min_value: 1
        max_value: 1000
        default: 20

# Security validation rules
security_validations:
  xss_prevention:
    enabled: true
    sanitize_inputs: true
    escape_outputs: true
    content_security_policy: true
    
  csrf_protection:
    enabled: true
    token_validation: true
    same_site_cookies: true
    
  sql_injection_prevention:
    enabled: true
    parameterized_queries: true
    input_sanitization: true
    
  information_disclosure_prevention:
    hide_system_errors: true
    sanitize_error_messages: true
    log_detailed_errors: true
    
  dos_prevention:
    rate_limiting: true
    request_size_limits: true
    timeout_limits: true

# Error response templates
error_responses:
  validation_error:
    status_code: 400
    response_template: |
      {
          "success": false,
          "error": {
              "type": "ValidationError",
              "message": "{error_message}",
              "details": {validation_details},
              "timestamp": "{timestamp}",
              "request_id": "{request_id}"
          }
      }

  authentication_error:
    status_code: 401
    response_template: |
      {
          "success": false,
          "error": {
              "type": "AuthenticationError",
              "message": "Authentication required",
              "timestamp": "{timestamp}",
              "request_id": "{request_id}"
          }
      }

  permission_error:
    status_code: 403
    response_template: |
      {
          "success": false,
          "error": {
              "type": "PermissionError", 
              "message": "Insufficient permissions",
              "timestamp": "{timestamp}",
              "request_id": "{request_id}"
          }
      }

  rate_limit_error:
    status_code: 429
    response_template: |
      {
          "success": false,
          "error": {
              "type": "RateLimitError",
              "message": "Rate limit exceeded",
              "retry_after": {retry_after_seconds},
              "timestamp": "{timestamp}",
              "request_id": "{request_id}"
          }
      }

# Usage examples
usage_examples:
  basic_validation:
    endpoint: "/api/method/myapp.api.create_customer"
    validation_schema: "create_document_schema"
    authentication: ["token", "session"]
    
  complex_validation:
    endpoint: "/api/method/myapp.api.bulk_update"
    custom_validation: |
      @frappe.whitelist()
      @validate_api_access(['token'])
      @validate_api_input({
          'required_fields': ['documents', 'field', 'value'],
          'field_validations': {
              'documents': {'type': 'list', 'max_length': 100},
              'field': {'type': 'string', 'max_length': 50},
              'value': {'type': 'string', 'max_length': 255}
          }
      })
      def bulk_update(documents, field, value):
          # API implementation
          pass

# Best practices
best_practices:
  - "Always validate and sanitize all inputs"
  - "Implement proper authentication for all endpoints"
  - "Use parameterized queries to prevent SQL injection"
  - "Sanitize outputs to prevent XSS attacks"
  - "Implement rate limiting to prevent abuse"
  - "Log all validation failures for monitoring"
  - "Return consistent error response formats"
  - "Don't expose internal system information in errors"
  - "Validate both data types and business logic"
  - "Use HTTPS for all API communications"
  - "Implement proper CORS policies"
  - "Validate file uploads thoroughly"
  - "Use strong authentication mechanisms"
  - "Implement proper session management"
  - "Monitor and alert on suspicious activity"