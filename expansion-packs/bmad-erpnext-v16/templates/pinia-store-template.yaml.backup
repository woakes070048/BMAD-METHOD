---
template_name: "Pinia Store Template"
template_type: "vue_state_management"
version: "1.0.0"
description: "Template for creating Pinia stores for state management in Vue 3 ERPNext applications"

# Basic store structure
basic_store:
  template: |
    import { defineStore } from 'pinia'
    import { ref, computed } from 'vue'
    // Use frappe.call() for API calls - NO frappe-ui
    
    export const use{StoreName}Store = defineStore('{store_name}', () => {
      // State
      const items = ref([])
      const loading = ref(false)
      const error = ref(null)
      const currentItem = ref(null)
      
      // Getters (computed)
      const itemCount = computed(() => items.value.length)
      const hasItems = computed(() => items.value.length > 0)
      const activeItems = computed(() => 
        items.value.filter(item => item.status === 'Active')
      )
      
      // Actions
      const fetchItems = async () => {
        loading.value = true
        error.value = null
        
        try {
          const response = await frappe.call({
            method: 'app.api.get_items',
            args: {}
          })
          
          items.value = response.message
        } catch (err) {
          error.value = err.message
          console.error('Error fetching items:', err)
        } finally {
          loading.value = false
        }
      }
      
      const addItem = async (itemData) => {
        try {
          const response = await frappe.call({
            method: 'app.api.create_item',
            args: itemData
          })
          
          items.value.push(response.message)
          return response.message
        } catch (err) {
          error.value = err.message
          throw err
        }
      }
      
      const updateItem = async (id, updates) => {
        try {
          const response = await frappe.call({
            method: 'app.api.update_item',
            args: { id, ...updates }
          })
          
          const index = items.value.findIndex(item => item.id === id)
          if (index !== -1) {
            items.value[index] = response.message
          }
          
          return response.message
        } catch (err) {
          error.value = err.message
          throw err
        }
      }
      
      const deleteItem = async (id) => {
        try {
          await frappe.call({
            method: 'app.api.delete_item',
            args: { id }
          })
          
          items.value = items.value.filter(item => item.id !== id)
        } catch (err) {
          error.value = err.message
          throw err
        }
      }
      
      const setCurrentItem = (item) => {
        currentItem.value = item
      }
      
      const clearError = () => {
        error.value = null
      }
      
      const resetStore = () => {
        items.value = []
        loading.value = false
        error.value = null
        currentItem.value = null
      }
      
      return {
        // State
        items,
        loading,
        error,
        currentItem,
        
        // Getters
        itemCount,
        hasItems,
        activeItems,
        
        // Actions
        fetchItems,
        addItem,
        updateItem,
        deleteItem,
        setCurrentItem,
        clearError,
        resetStore
      }
    })

# Advanced store with resources
advanced_store:
  template: |
    import { defineStore } from 'pinia'
    import { ref, computed, watch } from 'vue'
    // Use frappe.call() for API calls - NO frappe-ui
    
    export const use{StoreName}Store = defineStore('{store_name}', () => {
      // State
      const filters = ref({})
      const sortBy = ref('creation desc')
      const currentPage = ref(1)
      const pageSize = ref(20)
      const selectedItems = ref([])
      
      // API Methods using frappe.call()
      async function fetchList() {
        try {
          const result = await frappe.call({
            method: 'frappe.client.get_list',
            args: {
              doctype: '{DocType}',
              fields: ['*'],
              filters: filters.value,
              order_by: sortBy.value,
              limit_start: (currentPage.value - 1) * pageSize.value,
              limit_page_length: pageSize.value
            }
          });
          // Transform data if needed
          console.log('Data loaded successfully:', result.message.length, 'items');
          return result.message;
        } catch (error) {
          console.error('Error loading data:', error);
          frappe.show_alert({
            message: error.message,
            indicator: 'red'
          });
          throw error;
        }
      }
      
      async function createItem(doc) {
        try {
          const result = await frappe.call({
            method: 'frappe.client.save',
            args: { doc }
          });
          await fetchList();
          frappe.show_alert({
            message: 'Item created successfully',
            indicator: 'green'
          });
          return result.message;
        } catch (error) {
          frappe.show_alert({
            message: error.message,
            indicator: 'red'
          });
          throw error;
        }
      }
      
      async function updateItem(doc) {
        try {
          const result = await frappe.call({
            method: 'frappe.client.save',
            args: { doc }
          });
          await fetchList();
          frappe.show_alert({
            message: 'Item updated successfully',
            indicator: 'green'
          });
          return result.message;
        } catch (error) {
          frappe.show_alert({
            message: error.message,
            indicator: 'red'
          });
          throw error;
        }
      }
      
      async function deleteItem(doctype, name) {
        try {
          await frappe.call({
            method: 'frappe.client.delete',
            args: {
              doctype: doctype,
              name: name
            }
          });
          await fetchList();
          frappe.show_alert({
            message: 'Item deleted successfully',
            indicator: 'green'
          });
        } catch (error) {
          frappe.show_alert({
            message: error.message,
            indicator: 'red'
          });
          throw error;
        }
      }
      
      // State for data
      const items = ref([])
      const loading = ref(false)
      const totalItems = computed(() => items.value.length)
      const totalPages = computed(() => Math.ceil(totalItems.value / pageSize.value))
      const hasSelection = computed(() => selectedItems.value.length > 0)
      
      // Watchers
      watch([filters, sortBy, currentPage], () => {
        fetchList()
      }, { deep: true })
      
      // Actions
      const loadData = async () => {
        loading.value = true;
        try {
          items.value = await fetchList();
        } finally {
          loading.value = false;
        }
      }
      
      const setFilters = (newFilters) => {
        filters.value = { ...newFilters }
        currentPage.value = 1 // Reset to first page
      }
      
      const setSorting = (field, direction = 'asc') => {
        sortBy.value = `${field} ${direction}`
      }
      
      const setPage = (page) => {
        currentPage.value = page
      }
      
      const setPageSize = (size) => {
        pageSize.value = size
        currentPage.value = 1
      }
      
      // These functions are already defined above
      // Just reference them in the return statement
      }
      
      const selectItem = (item) => {
        const index = selectedItems.value.findIndex(i => i.name === item.name)
        if (index > -1) {
          selectedItems.value.splice(index, 1)
        } else {
          selectedItems.value.push(item)
        }
      }
      
      const selectAll = () => {
        selectedItems.value = [...items.value]
      }
      
      const clearSelection = () => {
        selectedItems.value = []
      }
      
      const isSelected = (item) => {
        return selectedItems.value.some(i => i.name === item.name)
      }
      
      return {
        // State
        filters,
        sortBy,
        currentPage,
        pageSize,
        selectedItems,
        
        // Resources
        // API functions
        fetchList,
        createItem,
        updateItem,
        deleteItem,
        
        // Computed
        items,
        loading,
        totalItems,
        totalPages,
        hasSelection,
        
        // Actions
        loadData,
        setFilters,
        setSorting,
        setPage,
        setPageSize,
        createItem,
        updateItem,
        deleteItem,
        selectItem,
        selectAll,
        clearSelection,
        isSelected
      }
    })

# Auth store pattern
auth_store:
  template: |
    import { defineStore } from 'pinia'
    import { ref, computed } from 'vue'
    // Use frappe.call() for API calls - NO frappe-ui
    
    export const useAuthStore = defineStore('auth', () => {
      // State
      const user = ref(null)
      const isAuthenticated = ref(false)
      const permissions = ref({})
      const roles = ref([])
      const loading = ref(false)
      
      // API Methods
      async function doLogin(credentials) {
        try {
          const data = await frappe.call({
            method: 'login',
            args: credentials
          });
          user.value = data.message.user;
          isAuthenticated.value = true;
          permissions.value = data.message.permissions || {};
          roles.value = data.message.roles || [];
          
          // Store in localStorage
          localStorage.setItem('auth_user', JSON.stringify(data.message.user));
          
          frappe.show_alert({
            message: `Welcome ${data.message.user.full_name}!`,
            indicator: 'green'
          });
          return data.message;
        } catch (error) {
          frappe.show_alert({
            message: `Login Failed: ${error.message}`,
            indicator: 'red'
          });
          throw error;
        }
      }
      
      async function doLogout() {
        try {
          await frappe.call('logout');
          resetAuth();
          frappe.show_alert({
            message: 'You have been successfully logged out',
            indicator: 'blue'
          });
        } catch (error) {
          console.error('Logout error:', error);
        }
      }
      
      async function fetchProfile() {
        try {
          const result = await frappe.call({
            method: 'frappe.auth.get_logged_user'
          });
          user.value = result.message;
          isAuthenticated.value = true;
          return result.message;
        } catch (error) {
          console.error('Profile fetch error:', error);
          throw error;
        }
      }
      
      // Computed
      const userName = computed(() => user.value?.full_name || '')
      const userEmail = computed(() => user.value?.email || '')
      const isSystemManager = computed(() => roles.value.includes('System Manager'))
      const hasRole = computed(() => (roleName) => roles.value.includes(roleName))
      
      // Actions
      const login = async (credentials) => {
        loading.value = true;
        try {
          await doLogin(credentials);
        } finally {
          loading.value = false;
        }
      }
      
      const logout = async () => {
        await doLogout();
      }
      
      const checkAuth = async () => {
        // Check if user is stored in localStorage
        const storedUser = localStorage.getItem('auth_user')
        if (storedUser) {
          try {
            user.value = JSON.parse(storedUser)
            isAuthenticated.value = true
            
            // Verify with server
            await fetchProfile()
          } catch (error) {
            console.error('Auth check failed:', error)
            resetAuth()
          }
        }
      }
      
      const hasPermission = (doctype, action = 'read') => {
        return permissions.value[doctype]?.[action] || false
      }
      
      const canRead = (doctype) => hasPermission(doctype, 'read')
      const canWrite = (doctype) => hasPermission(doctype, 'write')
      const canCreate = (doctype) => hasPermission(doctype, 'create')
      const canDelete = (doctype) => hasPermission(doctype, 'delete')
      
      const updateProfile = async (profileData) => {
        try {
          const response = await frappe.call({
            method: 'frappe.auth.update_profile',
            args: profileData
          })
          
          user.value = { ...user.value, ...response.message }
          localStorage.setItem('auth_user', JSON.stringify(user.value))
          
          frappe.toast({
            title: 'Profile Updated',
            variant: 'success'
          })
        } catch (error) {
          frappe.toast({
            title: 'Update Failed',
            text: error.message,
            variant: 'error'
          })
          throw error
        }
      }
      
      const resetAuth = () => {
        user.value = null
        isAuthenticated.value = false
        permissions.value = {}
        roles.value = []
        localStorage.removeItem('auth_user')
      }
      
      return {
        // State
        user,
        isAuthenticated,
        permissions,
        roles,
        loading,
        
        // API Methods
        doLogin,
        doLogout,
        fetchProfile,
        
        // Computed
        userName,
        userEmail,
        isSystemManager,
        hasRole,
        
        // Actions
        login,
        logout,
        checkAuth,
        hasPermission,
        canRead,
        canWrite,
        canCreate,
        canDelete,
        updateProfile,
        resetAuth
      }
    })

# UI state store
ui_store:
  template: |
    import { defineStore } from 'pinia'
    import { ref, computed } from 'vue'
    
    export const useUIStore = defineStore('ui', () => {
      // State
      const sidebarOpen = ref(true)
      const theme = ref('light')
      const notifications = ref([])
      const modals = ref({})
      const loading = ref(false)
      const breadcrumbs = ref([])
      const pageTitle = ref('')
      
      // Computed
      const isDarkMode = computed(() => theme.value === 'dark')
      const unreadNotifications = computed(() => 
        notifications.value.filter(n => !n.read).length
      )
      const hasActiveModals = computed(() => 
        Object.values(modals.value).some(modal => modal.open)
      )
      
      // Actions
      const toggleSidebar = () => {
        sidebarOpen.value = !sidebarOpen.value
        localStorage.setItem('sidebar_open', sidebarOpen.value.toString())
      }
      
      const setSidebarOpen = (open) => {
        sidebarOpen.value = open
        localStorage.setItem('sidebar_open', open.toString())
      }
      
      const setTheme = (newTheme) => {
        theme.value = newTheme
        localStorage.setItem('theme', newTheme)
        
        // Apply theme to document
        document.documentElement.classList.toggle('dark', newTheme === 'dark')
      }
      
      const toggleTheme = () => {
        setTheme(theme.value === 'light' ? 'dark' : 'light')
      }
      
      const addNotification = (notification) => {
        const id = Date.now().toString()
        notifications.value.unshift({
          id,
          read: false,
          timestamp: new Date(),
          ...notification
        })
        
        // Auto-remove after 5 seconds if not persistent
        if (!notification.persistent) {
          setTimeout(() => {
            removeNotification(id)
          }, 5000)
        }
      }
      
      const removeNotification = (id) => {
        const index = notifications.value.findIndex(n => n.id === id)
        if (index > -1) {
          notifications.value.splice(index, 1)
        }
      }
      
      const markNotificationAsRead = (id) => {
        const notification = notifications.value.find(n => n.id === id)
        if (notification) {
          notification.read = true
        }
      }
      
      const clearAllNotifications = () => {
        notifications.value = []
      }
      
      const openModal = (modalId, props = {}) => {
        modals.value[modalId] = {
          open: true,
          props
        }
      }
      
      const closeModal = (modalId) => {
        if (modals.value[modalId]) {
          modals.value[modalId].open = false
        }
      }
      
      const closeAllModals = () => {
        Object.keys(modals.value).forEach(modalId => {
          modals.value[modalId].open = false
        })
      }
      
      const setLoading = (isLoading) => {
        loading.value = isLoading
      }
      
      const setBreadcrumbs = (crumbs) => {
        breadcrumbs.value = crumbs
      }
      
      const setPageTitle = (title) => {
        pageTitle.value = title
        document.title = title
      }
      
      const initializeUI = () => {
        // Load saved preferences
        const savedSidebar = localStorage.getItem('sidebar_open')
        if (savedSidebar !== null) {
          sidebarOpen.value = savedSidebar === 'true'
        }
        
        const savedTheme = localStorage.getItem('theme')
        if (savedTheme) {
          setTheme(savedTheme)
        }
      }
      
      return {
        // State
        sidebarOpen,
        theme,
        notifications,
        modals,
        loading,
        breadcrumbs,
        pageTitle,
        
        // Computed
        isDarkMode,
        unreadNotifications,
        hasActiveModals,
        
        // Actions
        toggleSidebar,
        setSidebarOpen,
        setTheme,
        toggleTheme,
        addNotification,
        removeNotification,
        markNotificationAsRead,
        clearAllNotifications,
        openModal,
        closeModal,
        closeAllModals,
        setLoading,
        setBreadcrumbs,
        setPageTitle,
        initializeUI
      }
    })

# Form store pattern
form_store:
  template: |
    import { defineStore } from 'pinia'
    import { ref, computed } from 'vue'
    // Use frappe.call() for API calls - NO frappe-ui
    
    export const useFormStore = defineStore('form', () => {
      // State
      const formData = ref({})
      const originalData = ref({})
      const errors = ref({})
      const touched = ref({})
      const submitting = ref(false)
      const mode = ref('create') // create, edit, view
      const doctype = ref('')
      const docname = ref('')
      
      // API Methods
      async function fetchDoc(doctype, name) {
        try {
          const result = await frappe.call({
            method: 'frappe.client.get',
            args: {
              doctype: doctype,
              name: name
            }
          });
          setFormData(result.message);
          mode.value = 'edit';
          return result.message;
        } catch (error) {
          console.error('Error fetching document:', error);
          throw error;
        }
      }
      
      async function saveDoc() {
        try {
          const result = await frappe.call({
            method: 'frappe.client.save',
            args: {
              doc: formData.value
            }
          });
          setFormData(result.message);
          mode.value = 'edit';
          docname.value = result.message.name;
          
          frappe.show_alert({
            message: 'Document saved successfully',
            indicator: 'green'
          });
          return result.message;
        } catch (error) {
          if (error.validation_errors) {
            setErrors(error.validation_errors);
          }
          frappe.show_alert({
            message: error.message || 'Save failed',
            indicator: 'red'
          });
          throw error;
        }
      }
      
      // Computed
      const isDirty = computed(() => {
        return JSON.stringify(formData.value) !== JSON.stringify(originalData.value)
      })
      
      const isValid = computed(() => {
        return Object.keys(errors.value).length === 0
      })
      
      const hasErrors = computed(() => {
        return Object.keys(errors.value).length > 0
      })
      
      const canSave = computed(() => {
        return isDirty.value && isValid.value && !submitting.value
      })
      
      // Actions
      const loadDocument = async (doctypeName, name) => {
        doctype.value = doctypeName
        docname.value = name
        
        await fetchDoc(doctypeName, name)
      }
      
      const setFormData = (data) => {
        formData.value = { ...data }
        originalData.value = { ...data }
        clearErrors()
      }
      
      const updateField = (fieldname, value) => {
        formData.value[fieldname] = value
        touched.value[fieldname] = true
        
        // Clear field error when value changes
        if (errors.value[fieldname]) {
          delete errors.value[fieldname]
        }
      }
      
      const setFieldError = (fieldname, error) => {
        errors.value[fieldname] = error
      }
      
      const setErrors = (errorObj) => {
        errors.value = { ...errorObj }
      }
      
      const clearErrors = () => {
        errors.value = {}
      }
      
      const clearFieldError = (fieldname) => {
        if (errors.value[fieldname]) {
          delete errors.value[fieldname]
        }
      }
      
      const validateField = (fieldname, value, rules = []) => {
        for (const rule of rules) {
          const error = rule(value)
          if (error) {
            setFieldError(fieldname, error)
            return false
          }
        }
        clearFieldError(fieldname)
        return true
      }
      
      const save = async () => {
        if (!canSave.value) return
        
        submitting.value = true
        
        try {
          formData.value.doctype = doctype.value;
          if (docname.value) {
            formData.value.name = docname.value;
          }
          await saveDoc()
        } finally {
          submitting.value = false
        }
      }
      
      const reset = () => {
        formData.value = { ...originalData.value }
        clearErrors()
        touched.value = {}
      }
      
      const newDocument = (doctypeName) => {
        doctype.value = doctypeName
        docname.value = ''
        mode.value = 'create'
        formData.value = {}
        originalData.value = {}
        clearErrors()
        touched.value = {}
      }
      
      return {
        // State
        formData,
        originalData,
        errors,
        touched,
        submitting,
        mode,
        doctype,
        docname,
        
        // API Methods
        fetchDoc,
        saveDoc,
        
        // Computed
        isDirty,
        isValid,
        hasErrors,
        canSave,
        
        // Actions
        loadDocument,
        setFormData,
        updateField,
        setFieldError,
        setErrors,
        clearErrors,
        clearFieldError,
        validateField,
        save,
        reset,
        newDocument
      }
    })

# Store composition patterns
store_composition:
  composable_pattern: |
    // useStoreComposition.js
    import { useAuthStore } from './auth'
    import { useUIStore } from './ui'
    import { useFormStore } from './form'
    
    export function useStores() {
      const auth = useAuthStore()
      const ui = useUIStore()
      const form = useFormStore()
      
      return {
        auth,
        ui,
        form
      }
    }
    
    // In components
    export default {
      setup() {
        const { auth, ui, form } = useStores()
        
        return {
          auth,
          ui,
          form
        }
      }
    }

  cross_store_actions: |
    // Store that uses other stores
    import { useAuthStore } from './auth'
    import { useUIStore } from './ui'
    
    export const useAppStore = defineStore('app', () => {
      const authStore = useAuthStore()
      const uiStore = useUIStore()
      
      const initialize = async () => {
        uiStore.setLoading(true)
        
        try {
          await authStore.checkAuth()
          uiStore.initializeUI()
          
          if (authStore.isAuthenticated) {
            // Load user-specific data
            await loadUserData()
          }
        } catch (error) {
          console.error('App initialization failed:', error)
        } finally {
          uiStore.setLoading(false)
        }
      }
      
      const loadUserData = async () => {
        // Load data specific to the authenticated user
      }
      
      return {
        initialize,
        loadUserData
      }
    })

# Plugin integration
plugin_integration:
  pinia_setup: |
    // main.js
    import { createApp } from 'vue'
    import { createPinia } from 'pinia'
    import App from './App.vue'
    
    const app = createApp(App)
    const pinia = createPinia()
    
    // Add plugins to Pinia
    pinia.use(({ store }) => {
      // Add $frappe to all stores
      store.$frappe = frappe
      
      // Add common utilities
      store.$toast = (message, variant = 'info') => {
        frappe.toast({ text: message, variant })
      }
      
      // Add error handler
      store.$handleError = (error) => {
        console.error('Store error:', error)
        frappe.toast({
          title: 'Error',
          text: error.message || 'An error occurred',
          variant: 'error'
        })
      }
    })
    
    app.use(pinia)
    app.mount('#app')

  persistence_plugin: |
    // Pinia persistence plugin
    export function createPersistedState(options = {}) {
      return ({ store }) => {
        const { persist = [], storage = localStorage } = options
        
        if (persist.includes(store.$id)) {
          // Load persisted state
          const persistedState = storage.getItem(`pinia_${store.$id}`)
          if (persistedState) {
            try {
              const parsed = JSON.parse(persistedState)
              store.$patch(parsed)
            } catch (error) {
              console.error('Failed to load persisted state:', error)
            }
          }
          
          // Subscribe to changes
          store.$subscribe((mutation, state) => {
            try {
              storage.setItem(`pinia_${store.$id}`, JSON.stringify(state))
            } catch (error) {
              console.error('Failed to persist state:', error)
            }
          })
        }
      }
    }
    
    // Usage
    pinia.use(createPersistedState({
      persist: ['auth', 'ui'],
      storage: localStorage
    }))

# Testing patterns
testing_patterns:
  store_testing: |
    // store.test.js
    // Use Frappe's test framework instead of Vitest
    // Run tests with: bench --site [site] run-tests --app [app-name]
    import { setActivePinia, createPinia } from 'pinia'
    import { useItemStore } from './itemStore'
    
    describe('Item Store', () => {
      beforeEach(() => {
        setActivePinia(createPinia())
      })
      
      it('should initialize with empty state', () => {
        const store = useItemStore()
        
        expect(store.items).toEqual([])
        expect(store.loading).toBe(false)
        expect(store.error).toBeNull()
      })
      
      it('should add item to store', async () => {
        const store = useItemStore()
        const mockItem = { id: 1, name: 'Test Item' }
        
        // Mock the API call
        vi.spyOn(frappe, 'call').mockResolvedValue({ message: mockItem })
        
        await store.addItem(mockItem)
        
        expect(store.items).toContain(mockItem)
        expect(store.itemCount).toBe(1)
      })
      
      it('should handle errors correctly', async () => {
        const store = useItemStore()
        const error = new Error('API Error')
        
        vi.spyOn(frappe, 'call').mockRejectedValue(error)
        
        await expect(store.addItem({})).rejects.toThrow('API Error')
        expect(store.error).toBe('API Error')
      })
    })

  component_testing: |
    // component.test.js
    import { mount } from '@vue/test-utils'
    import { createTestingPinia } from '@pinia/testing'
    import MyComponent from './MyComponent.vue'
    import { useItemStore } from './stores/itemStore'
    
    describe('MyComponent', () => {
      it('should interact with store correctly', () => {
        const wrapper = mount(MyComponent, {
          global: {
            plugins: [
              createTestingPinia({
                createSpy: vi.fn,
                initialState: {
                  item: {
                    items: [{ id: 1, name: 'Test' }]
                  }
                }
              })
            ]
          }
        })
        
        const store = useItemStore()
        
        // Test component behavior
        expect(wrapper.text()).toContain('Test')
        
        // Test store interaction
        wrapper.find('[data-test="add-button"]').trigger('click')
        expect(store.addItem).toHaveBeenCalled()
      })
    })

# Best practices
best_practices:
  - "Use composition API with Pinia for better TypeScript support"
  - "Keep stores focused on single responsibility"
  - "Use computed properties for derived state"
  - "Handle errors gracefully with proper user feedback"
  - "Implement loading states for async operations"
  - "Use resources from frappe-ui for API calls"
  - "Persist important state to localStorage when needed"
  - "Write tests for store logic"
  - "Use TypeScript for better type safety"
  - "Avoid direct mutation of state outside actions"
  - "Use meaningful names for stores and actions"
  - "Document complex store logic"
  - "Consider performance implications of reactive state"
  - "Use store composition for complex applications"
  - "Implement proper cleanup in stores when needed"