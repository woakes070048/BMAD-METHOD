name: "websocket-integration-template"
title: "WebSocket Real-time Integration Template"
description: "Real-time updates using Socket.io for ERPNext apps"
version: "2.0.0"

parameters:
  app_name:
    type: "string"
    required: true
    description: "Name of the ERPNext app (snake_case)"
  site_name:
    type: "string"
    required: true
    description: "Site name for WebSocket connection"

templates:
  realtime_store: |
    // stores/realtime.js
    import { defineStore } from 'pinia'
    import { ref, computed } from 'vue'
    import { io } from 'socket.io-client'
    import { useAuthStore } from './auth'
    
    export const useRealtimeStore = defineStore('realtime', () => {
      // State
      const socket = ref(null)
      const connected = ref(false)
      const subscriptions = ref(new Map())
      const notifications = ref([])
      const onlineUsers = ref(new Set())
      
      // Getters
      const isConnected = computed(() => connected.value)
      const unreadNotifications = computed(() => 
        notifications.value.filter(n => !n.read)
      )
      
      // Actions
      function connect() {
        if (socket.value?.connected) return
        
        const authStore = useAuthStore()
        if (!authStore.isLoggedIn) return
        
        socket.value = io('{{site_name}}', {
          path: '/socket.io',
          transports: ['websocket', 'polling'],
          withCredentials: true,
          autoConnect: true,
        })
        
        setupEventListeners()
      }
      
      function disconnect() {
        if (socket.value) {
          socket.value.disconnect()
          socket.value = null
          connected.value = false
          subscriptions.value.clear()
          onlineUsers.value.clear()
        }
      }
      
      function setupEventListeners() {
        if (!socket.value) return
        
        // Connection events
        socket.value.on('connect', () => {
          connected.value = true
          console.log('Socket connected:', socket.value.id)
          
          // Re-subscribe to previously active subscriptions
          for (const [key, subscription] of subscriptions.value) {
            if (subscription.active) {
              socket.value.emit('doc_subscribe', subscription.params)
            }
          }
        })
        
        socket.value.on('disconnect', (reason) => {
          connected.value = false
          console.log('Socket disconnected:', reason)
        })
        
        socket.value.on('connect_error', (error) => {
          console.error('Socket connection error:', error)
        })
        
        // Document events
        socket.value.on('doc_update', handleDocumentUpdate)
        socket.value.on('doc_delete', handleDocumentDelete)
        socket.value.on('doc_create', handleDocumentCreate)
        
        // Notification events
        socket.value.on('notification', handleNotification)
        socket.value.on('user_notification', handleUserNotification)
        
        // User presence events
        socket.value.on('user_online', handleUserOnline)
        socket.value.on('user_offline', handleUserOffline)
        socket.value.on('user_typing', handleUserTyping)
        
        // System events
        socket.value.on('system_notification', handleSystemNotification)
        socket.value.on('maintenance_mode', handleMaintenanceMode)
      }
      
      // Document subscription management
      function subscribeToDocument(doctype, name, options = {}) {
        if (!socket.value?.connected) return
        
        const key = `${doctype}:${name}`
        const params = {
          doctype,
          name,
          ...options
        }
        
        subscriptions.value.set(key, {
          params,
          active: true,
          timestamp: Date.now()
        })
        
        socket.value.emit('doc_subscribe', params)
        console.log(`Subscribed to ${key}`)
      }
      
      function unsubscribeFromDocument(doctype, name) {
        if (!socket.value?.connected) return
        
        const key = `${doctype}:${name}`
        const subscription = subscriptions.value.get(key)
        
        if (subscription) {
          subscription.active = false
          socket.value.emit('doc_unsubscribe', subscription.params)
          subscriptions.value.delete(key)
          console.log(`Unsubscribed from ${key}`)
        }
      }
      
      function subscribeToDocType(doctype, filters = {}) {
        if (!socket.value?.connected) return
        
        const key = `doctype:${doctype}`
        const params = {
          doctype,
          filters,
          type: 'doctype'
        }
        
        subscriptions.value.set(key, {
          params,
          active: true,
          timestamp: Date.now()
        })
        
        socket.value.emit('doctype_subscribe', params)
        console.log(`Subscribed to DocType ${doctype}`)
      }
      
      // Event handlers
      function handleDocumentUpdate(data) {
        console.log('Document updated:', data)
        
        // Emit custom event for components to listen
        window.dispatchEvent(new CustomEvent('doc-update', {
          detail: {
            doctype: data.doctype,
            name: data.name,
            doc: data.doc,
            updated_fields: data.updated_fields
          }
        }))
      }
      
      function handleDocumentDelete(data) {
        console.log('Document deleted:', data)
        
        window.dispatchEvent(new CustomEvent('doc-delete', {
          detail: {
            doctype: data.doctype,
            name: data.name
          }
        }))
      }
      
      function handleDocumentCreate(data) {
        console.log('Document created:', data)
        
        window.dispatchEvent(new CustomEvent('doc-create', {
          detail: {
            doctype: data.doctype,
            name: data.name,
            doc: data.doc
          }
        }))
      }
      
      function handleNotification(data) {
        notifications.value.unshift({
          id: data.id || Date.now(),
          type: data.type || 'info',
          title: data.title,
          message: data.message,
          timestamp: new Date(),
          read: false,
          action: data.action,
          ...data
        })
        
        // Limit notifications to 100
        if (notifications.value.length > 100) {
          notifications.value = notifications.value.slice(0, 100)
        }
        
        // Show toast notification
        showToast(data)
      }
      
      function handleUserNotification(data) {
        // Handle user-specific notifications
        handleNotification({
          ...data,
          type: 'user',
          title: data.title || 'Notification',
        })
      }
      
      function handleUserOnline(data) {
        onlineUsers.value.add(data.user)
        console.log(`User ${data.user} is online`)
      }
      
      function handleUserOffline(data) {
        onlineUsers.value.delete(data.user)
        console.log(`User ${data.user} went offline`)
      }
      
      function handleUserTyping(data) {
        window.dispatchEvent(new CustomEvent('user-typing', {
          detail: data
        }))
      }
      
      function handleSystemNotification(data) {
        // Handle system-wide notifications (maintenance, updates, etc.)
        handleNotification({
          ...data,
          type: 'system',
          title: data.title || 'System Notification',
        })
      }
      
      function handleMaintenanceMode(data) {
        // Handle maintenance mode notifications
        handleNotification({
          type: 'warning',
          title: 'Maintenance Mode',
          message: data.message || 'System will be under maintenance soon',
          persistent: true,
        })
      }
      
      // Utility functions
      function showToast(notification) {
        // Use your preferred toast library
        if (window.showToast) {
          window.showToast({
            type: notification.type,
            title: notification.title,
            message: notification.message,
            duration: notification.type === 'error' ? 0 : 5000,
          })
        }
      }
      
      function markNotificationAsRead(notificationId) {
        const notification = notifications.value.find(n => n.id === notificationId)
        if (notification) {
          notification.read = true
        }
      }
      
      function clearNotifications() {
        notifications.value = []
      }
      
      function emitEvent(event, data) {
        if (socket.value?.connected) {
          socket.value.emit(event, data)
        }
      }
      
      function joinRoom(room) {
        if (socket.value?.connected) {
          socket.value.emit('join_room', { room })
        }
      }
      
      function leaveRoom(room) {
        if (socket.value?.connected) {
          socket.value.emit('leave_room', { room })
        }
      }
      
      return {
        // State
        socket,
        connected,
        subscriptions,
        notifications,
        onlineUsers,
        
        // Getters
        isConnected,
        unreadNotifications,
        
        // Actions
        connect,
        disconnect,
        subscribeToDocument,
        unsubscribeFromDocument,
        subscribeToDocType,
        markNotificationAsRead,
        clearNotifications,
        emitEvent,
        joinRoom,
        leaveRoom,
      }
    })

  document_realtime_composable: |
    // composables/useDocumentRealtime.js
    import { ref, onMounted, onUnmounted, watch } from 'vue'
    import { useRealtimeStore } from '@/stores/realtime'
    
    export function useDocumentRealtime(doctype, name, options = {}) {
      const realtimeStore = useRealtimeStore()
      const isSubscribed = ref(false)
      const lastUpdate = ref(null)
      const conflicts = ref([])
      
      // Auto-subscribe when component mounts
      const autoSubscribe = options.autoSubscribe !== false
      
      function subscribe() {
        if (!doctype || !name) return
        
        realtimeStore.subscribeToDocument(doctype, name, {
          fields: options.fields,
          filters: options.filters,
        })
        
        isSubscribed.value = true
        
        // Set up event listeners for this specific document
        setupDocumentListeners()
      }
      
      function unsubscribe() {
        if (!doctype || !name) return
        
        realtimeStore.unsubscribeFromDocument(doctype, name)
        isSubscribed.value = false
        
        // Clean up event listeners
        cleanupDocumentListeners()
      }
      
      function setupDocumentListeners() {
        window.addEventListener('doc-update', handleDocumentUpdate)
        window.addEventListener('doc-delete', handleDocumentDelete)
      }
      
      function cleanupDocumentListeners() {
        window.removeEventListener('doc-update', handleDocumentUpdate)
        window.removeEventListener('doc-delete', handleDocumentDelete)
      }
      
      function handleDocumentUpdate(event) {
        const { doctype: updatedDoctype, name: updatedName, doc, updated_fields } = event.detail
        
        if (updatedDoctype === doctype && updatedName === name) {
          lastUpdate.value = {
            doc,
            updated_fields,
            timestamp: new Date(),
          }
          
          // Check for conflicts if user is editing
          if (options.onUpdate) {
            options.onUpdate(doc, updated_fields)
          }
          
          // Detect edit conflicts
          if (options.detectConflicts && updated_fields) {
            detectEditConflicts(updated_fields)
          }
        }
      }
      
      function handleDocumentDelete(event) {
        const { doctype: deletedDoctype, name: deletedName } = event.detail
        
        if (deletedDoctype === doctype && deletedName === name) {
          if (options.onDelete) {
            options.onDelete()
          }
        }
      }
      
      function detectEditConflicts(updated_fields) {
        // Simple conflict detection - check if user is editing same fields
        if (options.currentlyEditing) {
          const editingFields = new Set(options.currentlyEditing)
          const updatedFieldsSet = new Set(updated_fields)
          
          const conflictingFields = [...editingFields].filter(field => 
            updatedFieldsSet.has(field)
          )
          
          if (conflictingFields.length > 0) {
            conflicts.value.push({
              fields: conflictingFields,
              timestamp: new Date(),
              resolved: false,
            })
            
            if (options.onConflict) {
              options.onConflict(conflictingFields)
            }
          }
        }
      }
      
      function resolveConflict(conflictIndex, resolution = 'accept') {
        if (conflicts.value[conflictIndex]) {
          conflicts.value[conflictIndex].resolved = true
          conflicts.value[conflictIndex].resolution = resolution
        }
      }
      
      function refreshDocument() {
        // Trigger a refresh of the document from server
        if (options.onRefresh) {
          options.onRefresh()
        }
      }
      
      // Lifecycle
      onMounted(() => {
        if (autoSubscribe && realtimeStore.isConnected) {
          subscribe()
        }
      })
      
      onUnmounted(() => {
        if (isSubscribed.value) {
          unsubscribe()
        }
      })
      
      // Watch for connection changes
      watch(
        () => realtimeStore.isConnected,
        (connected) => {
          if (connected && autoSubscribe && !isSubscribed.value) {
            subscribe()
          }
        }
      )
      
      return {
        isSubscribed,
        lastUpdate,
        conflicts,
        subscribe,
        unsubscribe,
        resolveConflict,
        refreshDocument,
      }
    }

  list_realtime_composable: |
    // composables/useListRealtime.js
    import { ref, onMounted, onUnmounted, watch } from 'vue'
    import { useRealtimeStore } from '@/stores/realtime'
    
    export function useListRealtime(doctype, options = {}) {
      const realtimeStore = useRealtimeStore()
      const isSubscribed = ref(false)
      const updates = ref([])
      const newDocuments = ref([])
      const deletedDocuments = ref([])
      
      function subscribe() {
        if (!doctype) return
        
        realtimeStore.subscribeToDocType(doctype, {
          filters: options.filters,
          fields: options.fields,
        })
        
        isSubscribed.value = true
        setupListeners()
      }
      
      function unsubscribe() {
        if (!doctype) return
        
        // Note: DocType unsubscription would need to be implemented
        isSubscribed.value = false
        cleanupListeners()
      }
      
      function setupListeners() {
        window.addEventListener('doc-create', handleDocumentCreate)
        window.addEventListener('doc-update', handleDocumentUpdate)
        window.addEventListener('doc-delete', handleDocumentDelete)
      }
      
      function cleanupListeners() {
        window.removeEventListener('doc-create', handleDocumentCreate)
        window.removeEventListener('doc-update', handleDocumentUpdate)
        window.removeEventListener('doc-delete', handleDocumentDelete)
      }
      
      function handleDocumentCreate(event) {
        const { doctype: createdDoctype, name, doc } = event.detail
        
        if (createdDoctype === doctype) {
          // Check if document matches filters
          if (matchesFilters(doc, options.filters)) {
            newDocuments.value.unshift({
              name,
              doc,
              timestamp: new Date(),
              acknowledged: false,
            })
            
            if (options.onDocumentCreate) {
              options.onDocumentCreate(doc)
            }
          }
        }
      }
      
      function handleDocumentUpdate(event) {
        const { doctype: updatedDoctype, name, doc, updated_fields } = event.detail
        
        if (updatedDoctype === doctype) {
          updates.value.unshift({
            name,
            doc,
            updated_fields,
            timestamp: new Date(),
            acknowledged: false,
          })
          
          if (options.onDocumentUpdate) {
            options.onDocumentUpdate(doc, updated_fields)
          }
        }
      }
      
      function handleDocumentDelete(event) {
        const { doctype: deletedDoctype, name } = event.detail
        
        if (deletedDoctype === doctype) {
          deletedDocuments.value.unshift({
            name,
            timestamp: new Date(),
            acknowledged: false,
          })
          
          if (options.onDocumentDelete) {
            options.onDocumentDelete(name)
          }
        }
      }
      
      function matchesFilters(doc, filters) {
        if (!filters) return true
        
        for (const [field, value] of Object.entries(filters)) {
          if (Array.isArray(value)) {
            // Handle operator filters like ['=', 'value'] or ['in', ['val1', 'val2']]
            const [operator, filterValue] = value
            
            switch (operator) {
              case '=':
                if (doc[field] !== filterValue) return false
                break
              case '!=':
                if (doc[field] === filterValue) return false
                break
              case 'in':
                if (!filterValue.includes(doc[field])) return false
                break
              case 'not in':
                if (filterValue.includes(doc[field])) return false
                break
              case '>':
                if (doc[field] <= filterValue) return false
                break
              case '<':
                if (doc[field] >= filterValue) return false
                break
              case 'like':
                const pattern = filterValue.replace(/%/g, '.*')
                if (!new RegExp(pattern, 'i').test(doc[field])) return false
                break
            }
          } else {
            // Simple equality check
            if (doc[field] !== value) return false
          }
        }
        
        return true
      }
      
      function acknowledgeUpdate(index) {
        if (updates.value[index]) {
          updates.value[index].acknowledged = true
        }
      }
      
      function acknowledgeNewDocument(index) {
        if (newDocuments.value[index]) {
          newDocuments.value[index].acknowledged = true
        }
      }
      
      function acknowledgeDeletedDocument(index) {
        if (deletedDocuments.value[index]) {
          deletedDocuments.value[index].acknowledged = true
        }
      }
      
      function clearAcknowledged() {
        updates.value = updates.value.filter(u => !u.acknowledged)
        newDocuments.value = newDocuments.value.filter(d => !d.acknowledged)
        deletedDocuments.value = deletedDocuments.value.filter(d => !d.acknowledged)
      }
      
      function getUnacknowledgedCount() {
        return {
          updates: updates.value.filter(u => !u.acknowledged).length,
          new: newDocuments.value.filter(d => !d.acknowledged).length,
          deleted: deletedDocuments.value.filter(d => !d.acknowledged).length,
        }
      }
      
      // Lifecycle
      onMounted(() => {
        if (options.autoSubscribe !== false && realtimeStore.isConnected) {
          subscribe()
        }
      })
      
      onUnmounted(() => {
        if (isSubscribed.value) {
          unsubscribe()
        }
      })
      
      watch(
        () => realtimeStore.isConnected,
        (connected) => {
          if (connected && options.autoSubscribe !== false && !isSubscribed.value) {
            subscribe()
          }
        }
      )
      
      return {
        isSubscribed,
        updates,
        newDocuments,
        deletedDocuments,
        subscribe,
        unsubscribe,
        acknowledgeUpdate,
        acknowledgeNewDocument,
        acknowledgeDeletedDocument,
        clearAcknowledged,
        getUnacknowledgedCount,
      }
    }

  backend_realtime_hooks: |
    # {{app_name}}/realtime_hooks.py
    """
    Real-time event hooks for document updates
    """
    
    import frappe
    from frappe.realtime import emit_via_redis
    from typing import Dict, Any, Optional, List
    
    
    def emit_document_update(doc, method=None, updated_fields=None):
        """
        Emit document update event to connected clients
        
        Args:
            doc: Document instance
            method: Document method (after_insert, on_update, etc.)
            updated_fields: List of updated field names
        """
        try:
            # Only emit for specific document types or if explicitly enabled
            if not should_emit_realtime_event(doc.doctype):
                return
            
            event_data = {
                "doctype": doc.doctype,
                "name": doc.name,
                "doc": get_sanitized_doc_data(doc),
                "updated_fields": updated_fields or [],
                "user": frappe.session.user,
                "timestamp": frappe.utils.now(),
            }
            
            # Emit to users with read permission
            users_with_permission = get_users_with_permission(doc.doctype, "read")
            
            for user in users_with_permission:
                emit_via_redis(
                    event="doc_update",
                    message=event_data,
                    user=user,
                    namespace="/{{app_name}}"
                )
            
            # Also emit to document-specific room
            emit_via_redis(
                event="doc_update",
                message=event_data,
                room=f"{doc.doctype}:{doc.name}",
                namespace="/{{app_name}}"
            )
            
        except Exception as e:
            frappe.log_error(f"Error emitting document update: {e}")
    
    
    def emit_document_create(doc, method=None):
        """Emit document creation event"""
        try:
            if not should_emit_realtime_event(doc.doctype):
                return
            
            event_data = {
                "doctype": doc.doctype,
                "name": doc.name,
                "doc": get_sanitized_doc_data(doc),
                "user": frappe.session.user,
                "timestamp": frappe.utils.now(),
            }
            
            users_with_permission = get_users_with_permission(doc.doctype, "read")
            
            for user in users_with_permission:
                emit_via_redis(
                    event="doc_create",
                    message=event_data,
                    user=user,
                    namespace="/{{app_name}}"
                )
            
            # Emit to doctype room for list views
            emit_via_redis(
                event="doc_create",
                message=event_data,
                room=f"doctype:{doc.doctype}",
                namespace="/{{app_name}}"
            )
            
        except Exception as e:
            frappe.log_error(f"Error emitting document create: {e}")
    
    
    def emit_document_delete(doc, method=None):
        """Emit document deletion event"""
        try:
            if not should_emit_realtime_event(doc.doctype):
                return
            
            event_data = {
                "doctype": doc.doctype,
                "name": doc.name,
                "user": frappe.session.user,
                "timestamp": frappe.utils.now(),
            }
            
            users_with_permission = get_users_with_permission(doc.doctype, "read")
            
            for user in users_with_permission:
                emit_via_redis(
                    event="doc_delete",
                    message=event_data,
                    user=user,
                    namespace="/{{app_name}}"
                )
            
            # Emit to document and doctype rooms
            emit_via_redis(
                event="doc_delete",
                message=event_data,
                room=f"{doc.doctype}:{doc.name}",
                namespace="/{{app_name}}"
            )
            
            emit_via_redis(
                event="doc_delete",
                message=event_data,
                room=f"doctype:{doc.doctype}",
                namespace="/{{app_name}}"
            )
            
        except Exception as e:
            frappe.log_error(f"Error emitting document delete: {e}")
    
    
    def should_emit_realtime_event(doctype: str) -> bool:
        """
        Check if real-time events should be emitted for this doctype
        
        Args:
            doctype: DocType name
        
        Returns:
            bool: Whether to emit events
        """
        # Configure which doctypes should emit real-time events
        realtime_doctypes = [
            "Customer",
            "Item",
            "Sales Order",
            "Purchase Order",
            "Task",
            "Project",
            # Add your app-specific doctypes
            # "{{app_name}} Custom DocType",
        ]
        
        # Check if doctype is from this app
        if doctype.startswith("{{app_name.title().replace('_', ' ')}}"):
            return True
        
        return doctype in realtime_doctypes
    
    
    def get_sanitized_doc_data(doc) -> Dict[str, Any]:
        """
        Get sanitized document data for real-time updates
        
        Args:
            doc: Document instance
        
        Returns:
            dict: Sanitized document data
        """
        try:
            doc_dict = doc.as_dict()
            
            # Remove sensitive fields
            sensitive_fields = ["password", "api_key", "api_secret", "access_token"]
            for field in sensitive_fields:
                if field in doc_dict:
                    del doc_dict[field]
            
            # Only include essential fields for performance
            essential_fields = [
                "name", "title", "subject", "status", "modified", "modified_by",
                "creation", "owner", "docstatus", "idx"
            ]
            
            # Add doctype-specific important fields
            meta = frappe.get_meta(doc.doctype)
            for field in meta.fields:
                if field.in_list_view or field.bold or field.reqd:
                    essential_fields.append(field.fieldname)
            
            # Filter to essential fields only
            filtered_dict = {k: v for k, v in doc_dict.items() if k in essential_fields}
            
            return filtered_dict
            
        except Exception as e:
            frappe.log_error(f"Error sanitizing doc data: {e}")
            return {"name": doc.name, "doctype": doc.doctype}
    
    
    def get_users_with_permission(doctype: str, permission: str) -> List[str]:
        """
        Get list of users with specific permission for a doctype
        
        Args:
            doctype: DocType name
            permission: Permission type (read, write, create, delete)
        
        Returns:
            list: List of user emails
        """
        try:
            # Get all active users
            users = frappe.get_all(
                "User",
                filters={"enabled": 1, "user_type": "System User"},
                fields=["name"]
            )
            
            users_with_permission = []
            
            for user in users:
                if frappe.has_permission(doctype, permission, user=user.name):
                    users_with_permission.append(user.name)
            
            return users_with_permission
            
        except Exception as e:
            frappe.log_error(f"Error getting users with permission: {e}")
            return []
    
    
    def emit_user_notification(user: str, title: str, message: str, **kwargs):
        """
        Send notification to specific user
        
        Args:
            user: User email
            title: Notification title
            message: Notification message
            **kwargs: Additional notification data
        """
        try:
            notification_data = {
                "title": title,
                "message": message,
                "type": kwargs.get("type", "info"),
                "timestamp": frappe.utils.now(),
                "action": kwargs.get("action"),
                "route": kwargs.get("route"),
                **kwargs
            }
            
            emit_via_redis(
                event="user_notification",
                message=notification_data,
                user=user,
                namespace="/{{app_name}}"
            )
            
        except Exception as e:
            frappe.log_error(f"Error emitting user notification: {e}")
    
    
    def emit_system_notification(title: str, message: str, **kwargs):
        """
        Send system-wide notification to all connected users
        
        Args:
            title: Notification title
            message: Notification message
            **kwargs: Additional notification data
        """
        try:
            notification_data = {
                "title": title,
                "message": message,
                "type": kwargs.get("type", "info"),
                "timestamp": frappe.utils.now(),
                **kwargs
            }
            
            emit_via_redis(
                event="system_notification",
                message=notification_data,
                namespace="/{{app_name}}"
            )
            
        except Exception as e:
            frappe.log_error(f"Error emitting system notification: {e}")

  hooks_py_realtime: |
    # Add to hooks.py
    
    # Document Events for Real-time Updates
    doc_events = {
        "*": {
            "after_insert": "{{app_name}}.realtime_hooks.emit_document_create",
            "on_update": "{{app_name}}.realtime_hooks.emit_document_update",
            "on_trash": "{{app_name}}.realtime_hooks.emit_document_delete",
        }
    }
    
    # WebSocket Events
    socketio_settings = {
        "cors_allowed_origins": "*",
        "async_mode": "threading",
    }

instructions:
  setup:
    - "Install socket.io-client: yarn add socket.io-client"
    - "Add realtime store to your Pinia setup"
    - "Create realtime_hooks.py in your app directory"
    - "Add WebSocket event hooks to hooks.py"
    - "Initialize realtime connection in your main App.vue"
  
  integration:
    - "Use composables in your Vue components for real-time features"
    - "Components automatically subscribe/unsubscribe to document updates"
    - "Built-in conflict detection for concurrent editing"
    - "Proper permission-based event filtering on backend"
    - "Optimized data transmission with essential fields only"
  
  usage:
    - "useDocumentRealtime() for single document real-time updates"
    - "useListRealtime() for list view real-time updates"
    - "Automatic reconnection and re-subscription handling"
    - "User presence and typing indicators support"
    - "System notifications and maintenance mode alerts"
  
  security:
    - "Permission-based event filtering"
    - "Sanitized document data transmission"
    - "User authentication for WebSocket connections"
    - "Room-based event distribution"