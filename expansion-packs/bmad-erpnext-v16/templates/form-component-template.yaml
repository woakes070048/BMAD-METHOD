---
template_name: "Form Component Template"
template_type: "vue_form_component"
version: "1.0.0"
description: "Template for creating reusable Vue 3 form components with native Frappe integration"

# ðŸš¨ CRITICAL: Page Integration Requirements
page_integration_requirements:
  mandatory_page_json: |
    {
      "title": "Form Page Title",        // MANDATORY - Never skip!
      "page_title": "Form Page",         // RECOMMENDED
      "name": "form-page",
      "module": "Module Name",
      "icon": "fa fa-edit",              // MANDATORY
      "roles": [{"role": "System Manager"}]
    }
  
  mandatory_page_setup: |
    // EVERY form page MUST set title in 3 places:
    frappe.pages['form-page'].on_page_load = function(wrapper) {
        var page = frappe.ui.make_app_page({
            parent: wrapper,
            title: 'Form Page Title',     // 1. SET HERE
            single_column: true
        });
        
        page.set_title(__('Form Page Title'));                                  // 2. Page header
        document.title = __('Form Page Title') + ' | ' + frappe.boot.sitename; // 3. Browser tab
        
        // Then mount the Vue form component
        frappe.require('form.bundle.js').then(() => {
            new FormComponent(wrapper);
        });
    }

# Form component structure
form_component_structure:
  basic_form: |
    <template>
      <div class="form-container">
        <form @submit.prevent="handleSubmit">
          <div class="form-header mb-4">
            <h2 class="h4">{{ formTitle }}</h2>
          </div>
          
          <div class="form-body">
            <slot></slot>
          </div>
          
          <div class="form-actions mt-4">
            <button
              type="button"
              class="btn btn-secondary mr-2"
              @click="handleCancel"
              :disabled="isSubmitting"
            >
              Cancel
            </button>
            <button
              type="submit"
              class="btn btn-primary"
              :disabled="isSubmitting"
            >
              <span v-if="isSubmitting" class="spinner-border spinner-border-sm mr-2"></span>
              {{ submitLabel }}
            </button>
          </div>
        </form>
      </div>
    </template>
    
    <script setup>
    import { ref, computed, watch } from 'vue'
    // Use native Vue components with Bootstrap 4 styling
    
    const props = defineProps({
      doctype: String,
      name: String,
      mode: {
        type: String,
        default: 'create' // create, edit, view
      }
    })
    
    const emit = defineEmits(['success', 'error', 'cancel'])
    
    const formData = ref({})
    const isSubmitting = ref(false)
    const errors = ref({})
    
    const formTitle = computed(() => {
      return props.mode === 'create' 
        ? `New ${props.doctype}`
        : `Edit ${props.doctype}`
    })
    
    const submitLabel = computed(() => {
      return props.mode === 'create' ? 'Create' : 'Update'
    })
    </script>

  advanced_form: |
    <template>
      <div class="advanced-form">
        <FormLayout>
          <FormSection title="Basic Information" :collapsible="true">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormControl
                v-model="formData.field1"
                label="Field 1"
                type="text"
                :required="true"
                :error="errors.field1"
                @change="validateField('field1')"
              />
              
              <FormControl
                v-model="formData.field2"
                label="Field 2"
                type="select"
                :options="field2Options"
                :error="errors.field2"
              />
            </div>
          </FormSection>
          
          <FormSection title="Additional Details">
            <FormControl
              v-model="formData.description"
              label="Description"
              type="textarea"
              :rows="4"
              :error="errors.description"
            />
            
            <FileUpload
              v-model="formData.attachments"
              label="Attachments"
              :multiple="true"
              :accept="'.pdf,.doc,.docx'"
              @upload="handleFileUpload"
            />
          </FormSection>
          
          <FormSection title="Table Items">
            <TableField
              v-model="formData.items"
              :columns="tableColumns"
              :can-add="true"
              :can-delete="true"
              @add-row="addTableRow"
              @delete-row="deleteTableRow"
            />
          </FormSection>
        </FormLayout>
      </div>
    </template>

# Form field patterns
form_field_patterns:
  text_field: |
    <div class="form-group">
      <label :for="fieldId" v-if="label">
        {{ label }}
        <span v-if="required" class="text-danger">*</span>
      </label>
      <input
        :id="fieldId"
        v-model="value"
        type="text"
        class="form-control"
        :class="{ 'is-invalid': error }"
        :placeholder="placeholder"
        :required="required"
        :disabled="disabled"
        :readonly="readonly"
        @change="handleChange"
        @blur="handleBlur"
        @focus="handleFocus"
      />
      <small v-if="helperText" class="form-text text-muted">{{ helperText }}</small>
      <div v-if="error" class="invalid-feedback">{{ error }}</div>
    </div>

  select_field: |
    <FormControl
      v-model="selectedValue"
      :label="label"
      type="select"
      :options="options"
      :required="required"
      :disabled="disabled"
      :error="error"
      :searchable="true"
      :multiple="false"
      @change="handleSelectChange"
    >
      <template #prefix>
        <Icon name="search" class="w-4 h-4" />
      </template>
    </FormControl>

  link_field: |
    <LinkField
      v-model="linkedDoc"
      :label="label"
      :doctype="targetDoctype"
      :filters="filters"
      :required="required"
      :create-new="allowCreate"
      @change="handleLinkChange"
    >
      <template #item="{ item }">
        <div class="flex items-center">
          <Avatar :label="item.name" size="sm" />
          <div class="ml-2">
            <div class="text-sm font-medium">{{ item.name }}</div>
            <div class="text-xs text-gray-600">{{ item.description }}</div>
          </div>
        </div>
      </template>
    </LinkField>

  date_field: |
    <FormControl
      v-model="dateValue"
      :label="label"
      type="date"
      :required="required"
      :min="minDate"
      :max="maxDate"
      :error="error"
      :format="'yyyy-MM-dd'"
      @change="handleDateChange"
    />

  checkbox_field: |
    <FormControl
      v-model="checked"
      :label="label"
      type="checkbox"
      :disabled="disabled"
      :error="error"
    >
      <template #description>
        {{ description }}
      </template>
    </FormControl>

  file_upload_field: |
    <FileUpload
      v-model="files"
      :label="label"
      :accept="acceptedTypes"
      :multiple="multiple"
      :max-size="maxFileSize"
      :error="error"
      @upload="handleUpload"
      @remove="handleRemove"
    >
      <template #empty>
        <div class="text-center py-8">
          <Icon name="upload" class="w-8 h-8 mx-auto mb-2 text-gray-400" />
          <p class="text-sm text-gray-600">Drop files here or click to upload</p>
        </div>
      </template>
    </FileUpload>

# Validation patterns
validation_patterns:
  validation_rules: |
    const validationRules = {
      email: [
        v => !!v || 'Email is required',
        v => /.+@.+\..+/.test(v) || 'Email must be valid'
      ],
      phone: [
        v => !!v || 'Phone is required',
        v => /^[0-9]{10}$/.test(v) || 'Phone must be 10 digits'
      ],
      required: [
        v => !!v || 'This field is required'
      ],
      minLength: (min) => [
        v => !v || v.length >= min || `Minimum ${min} characters required`
      ],
      maxLength: (max) => [
        v => !v || v.length <= max || `Maximum ${max} characters allowed`
      ],
      numeric: [
        v => !v || /^[0-9]+$/.test(v) || 'Must be numeric'
      ],
      alphanumeric: [
        v => !v || /^[a-zA-Z0-9]+$/.test(v) || 'Must be alphanumeric'
      ],
      url: [
        v => !v || /^https?:\/\/.+/.test(v) || 'Must be a valid URL'
      ]
    }

  async_validation: |
    const validateAsync = async (fieldName, value) => {
      try {
        const response = await frappe.call({
          method: 'app.validation.validate_field',
          args: {
            doctype: props.doctype,
            fieldname: fieldName,
            value: value
          }
        })
        
        if (!response.valid) {
          errors.value[fieldName] = response.message
          return false
        }
        
        errors.value[fieldName] = null
        return true
      } catch (error) {
        console.error('Validation error:', error)
        return false
      }
    }

  form_validation: |
    const validateForm = () => {
      const newErrors = {}
      let isValid = true
      
      // Required fields
      requiredFields.forEach(field => {
        if (!formData.value[field]) {
          newErrors[field] = `${field} is required`
          isValid = false
        }
      })
      
      // Custom validations
      if (formData.value.email && !isValidEmail(formData.value.email)) {
        newErrors.email = 'Invalid email format'
        isValid = false
      }
      
      if (formData.value.phone && !isValidPhone(formData.value.phone)) {
        newErrors.phone = 'Invalid phone number'
        isValid = false
      }
      
      // Date validations
      if (formData.value.start_date && formData.value.end_date) {
        if (new Date(formData.value.end_date) < new Date(formData.value.start_date)) {
          newErrors.end_date = 'End date must be after start date'
          isValid = false
        }
      }
      
      errors.value = newErrors
      return isValid
    }

# Form submission patterns
form_submission:
  basic_submission: |
    const handleSubmit = async () => {
      if (!validateForm()) {
        frappe.show_alert({
          message: 'Please fix the errors before submitting',
          indicator: 'red'
        })
        return
      }
      
      isSubmitting.value = true
      
      try {
        const result = await frappe.call({
          method: 'frappe.client.save',
          args: {
            doc: {
              doctype: props.doctype,
              ...formData.value
            }
          }
        })
        
        frappe.show_alert({
          message: `${props.doctype} saved successfully`,
          indicator: 'green'
        })
        
        emit('success', result.message)
        resetForm()
        
      } catch (error) {
        frappe.toast({
          title: 'Error',
          text: error.message || 'Failed to save',
          variant: 'error'
        })
        
        emit('error', error)
      } finally {
        isSubmitting.value = false
      }
    }

  with_confirmation: |
    const handleSubmitWithConfirmation = async () => {
      const confirmed = await frappe.confirm({
        title: 'Confirm Submission',
        message: 'Are you sure you want to submit this form?',
        primaryAction: {
          label: 'Submit',
          variant: 'solid'
        }
      })
      
      if (confirmed) {
        await handleSubmit()
      }
    }

  draft_save: |
    const saveDraft = async () => {
      const draftData = {
        ...formData.value,
        docstatus: 0, // Draft status
        __draft: true
      }
      
      try {
        // Save to local storage
        localStorage.setItem(
          `draft_${props.doctype}_${Date.now()}`,
          JSON.stringify(draftData)
        )
        
        // Optional: Save to server
        await frappe.call({
          method: 'app.drafts.save_draft',
          args: {
            doctype: props.doctype,
            data: draftData
          }
        })
        
        frappe.toast({
          title: 'Draft Saved',
          text: 'Your progress has been saved',
          variant: 'info'
        })
      } catch (error) {
        console.error('Failed to save draft:', error)
      }
    }

# Dynamic form patterns
dynamic_forms:
  conditional_fields: |
    const conditionalFields = computed(() => {
      const fields = [...baseFields]
      
      // Show additional fields based on type
      if (formData.value.type === 'advanced') {
        fields.push({
          fieldname: 'advanced_option',
          label: 'Advanced Option',
          fieldtype: 'Select',
          options: advancedOptions
        })
      }
      
      // Show fields based on role
      if (hasRole('Manager')) {
        fields.push({
          fieldname: 'approval_status',
          label: 'Approval Status',
          fieldtype: 'Select',
          options: ['Pending', 'Approved', 'Rejected']
        })
      }
      
      return fields
    })

  field_dependencies: |
    // Watch for field changes and update dependent fields
    watch(() => formData.value.country, (newCountry) => {
      if (newCountry) {
        // Load states for selected country
        loadStatesForCountry(newCountry)
        // Reset dependent fields
        formData.value.state = null
        formData.value.city = null
      }
    })
    
    watch(() => formData.value.state, (newState) => {
      if (newState) {
        // Load cities for selected state
        loadCitiesForState(newState)
        // Reset dependent field
        formData.value.city = null
      }
    })

  dynamic_validation: |
    const dynamicValidationRules = computed(() => {
      const rules = {}
      
      // Add validation based on form state
      if (formData.value.require_approval) {
        rules.approver = [v => !!v || 'Approver is required when approval is needed']
        rules.approval_notes = [v => !!v || 'Approval notes are required']
      }
      
      // Add validation based on field values
      if (formData.value.amount > 10000) {
        rules.justification = [v => !!v || 'Justification required for amounts over 10,000']
      }
      
      return rules
    })

# Table field patterns
table_field_patterns:
  basic_table: |
    <TableField
      v-model="items"
      :columns="columns"
      :can-add="true"
      :can-delete="true"
      :can-edit="true"
    >
      <template #empty>
        <div class="text-center py-4 text-gray-500">
          No items added yet
        </div>
      </template>
      
      <template #cell="{ column, row, value }">
        <div v-if="column.key === 'amount'">
          {{ formatCurrency(value) }}
        </div>
        <div v-else-if="column.key === 'actions'">
          <Button
            variant="ghost"
            size="sm"
            @click="editRow(row)"
          >
            Edit
          </Button>
        </div>
        <div v-else>
          {{ value }}
        </div>
      </template>
    </TableField>

  editable_table: |
    const tableColumns = [
      {
        key: 'item_code',
        label: 'Item',
        type: 'Link',
        options: 'Item',
        required: true,
        width: '200px'
      },
      {
        key: 'quantity',
        label: 'Quantity',
        type: 'Float',
        default: 1,
        width: '100px'
      },
      {
        key: 'rate',
        label: 'Rate',
        type: 'Currency',
        width: '120px'
      },
      {
        key: 'amount',
        label: 'Amount',
        type: 'Currency',
        readonly: true,
        formula: (row) => row.quantity * row.rate,
        width: '120px'
      }
    ]
    
    const addTableRow = () => {
      items.value.push({
        item_code: '',
        quantity: 1,
        rate: 0,
        amount: 0
      })
    }
    
    const deleteTableRow = (index) => {
      items.value.splice(index, 1)
      recalculateTotals()
    }

# Form state management
form_state_management:
  form_store: |
    // Using Pinia for form state
    import { defineStore } from 'pinia'
    
    export const useFormStore = defineStore('form', {
      state: () => ({
        formData: {},
        originalData: {},
        isDirty: false,
        errors: {},
        isSubmitting: false,
        mode: 'create'
      }),
      
      getters: {
        hasChanges: (state) => {
          return JSON.stringify(state.formData) !== JSON.stringify(state.originalData)
        },
        
        isValid: (state) => {
          return Object.keys(state.errors).length === 0
        }
      },
      
      actions: {
        setFormData(data) {
          this.formData = { ...data }
          this.originalData = { ...data }
          this.isDirty = false
        },
        
        updateField(field, value) {
          this.formData[field] = value
          this.isDirty = true
        },
        
        setError(field, error) {
          this.errors[field] = error
        },
        
        clearErrors() {
          this.errors = {}
        },
        
        resetForm() {
          this.formData = { ...this.originalData }
          this.isDirty = false
          this.errors = {}
        }
      }
    })

  auto_save: |
    // Auto-save functionality
    const { pause, resume } = useIntervalFn(() => {
      if (isDirty.value && !isSubmitting.value) {
        saveDraft()
      }
    }, 30000) // Auto-save every 30 seconds
    
    // Pause auto-save during submission
    watch(isSubmitting, (submitting) => {
      if (submitting) {
        pause()
      } else {
        resume()
      }
    })
    
    // Save on page unload
    onBeforeUnmount(() => {
      if (isDirty.value) {
        saveDraft()
      }
    })

# Form layouts
form_layouts:
  two_column: |
    <template>
      <div class="form-layout-two-column">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="left-column space-y-4">
            <!-- Left column fields -->
          </div>
          <div class="right-column space-y-4">
            <!-- Right column fields -->
          </div>
        </div>
      </div>
    </template>

  wizard_layout: |
    <template>
      <div class="form-wizard">
        <Steps :current="currentStep" :items="steps" />
        
        <div class="wizard-content mt-6">
          <transition name="slide-fade" mode="out-in">
            <component
              :is="currentStepComponent"
              v-model="formData"
              @next="nextStep"
              @previous="previousStep"
            />
          </transition>
        </div>
        
        <div class="wizard-actions flex justify-between mt-6">
          <Button
            v-if="currentStep > 0"
            variant="ghost"
            @click="previousStep"
          >
            Previous
          </Button>
          
          <Button
            v-if="currentStep < steps.length - 1"
            variant="solid"
            @click="nextStep"
          >
            Next
          </Button>
          
          <Button
            v-if="currentStep === steps.length - 1"
            variant="solid"
            @click="handleSubmit"
          >
            Submit
          </Button>
        </div>
      </div>
    </template>

  tabs_layout: |
    <template>
      <div class="form-tabs">
        <Tabs v-model="activeTab">
          <TabList>
            <Tab value="general">General</Tab>
            <Tab value="details">Details</Tab>
            <Tab value="settings">Settings</Tab>
          </TabList>
          
          <TabPanels>
            <TabPanel value="general">
              <!-- General fields -->
            </TabPanel>
            
            <TabPanel value="details">
              <!-- Detail fields -->
            </TabPanel>
            
            <TabPanel value="settings">
              <!-- Settings fields -->
            </TabPanel>
          </TabPanels>
        </Tabs>
      </div>
    </template>

# Error handling
error_handling:
  field_errors: |
    const handleFieldError = (field, error) => {
      errors.value[field] = error.message
      
      // Scroll to first error field
      nextTick(() => {
        const errorElement = document.querySelector(`[data-field="${field}"]`)
        if (errorElement) {
          errorElement.scrollIntoView({ behavior: 'smooth', block: 'center' })
          errorElement.focus()
        }
      })
    }

  submission_errors: |
    const handleSubmissionError = (error) => {
      if (error.exc_type === 'ValidationError') {
        // Handle validation errors
        const fieldErrors = parseValidationErrors(error)
        Object.assign(errors.value, fieldErrors)
        
        frappe.toast({
          title: 'Validation Failed',
          text: 'Please fix the highlighted errors',
          variant: 'error'
        })
      } else if (error.exc_type === 'PermissionError') {
        // Handle permission errors
        frappe.toast({
          title: 'Permission Denied',
          text: 'You do not have permission to perform this action',
          variant: 'error'
        })
      } else {
        // Handle generic errors
        frappe.toast({
          title: 'Error',
          text: error.message || 'An unexpected error occurred',
          variant: 'error'
        })
      }
    }

# Best practices
best_practices:
  - "Use controlled components for all form inputs"
  - "Implement proper validation on both client and server"
  - "Provide clear error messages and guidance"
  - "Show loading states during async operations"
  - "Implement auto-save for long forms"
  - "Use proper accessibility attributes"
  - "Handle edge cases and network errors"
  - "Optimize for mobile devices"
  - "Implement keyboard navigation"
  - "Provide visual feedback for all actions"
  - "Use consistent styling and spacing"
  - "Test with different data scenarios"
  - "Implement proper cleanup on unmount"
  - "Cache form data to prevent loss"
  - "Follow Frappe UI design patterns"